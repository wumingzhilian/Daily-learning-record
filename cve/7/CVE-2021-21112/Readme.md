与上一个漏洞类似该漏洞也涉及到了Resolve，这里再次回顾一下：
```
// static
MaybeHandle<Object> JSPromise::Resolve(Handle<JSPromise> promise,
                                       Handle<Object> resolution) {
  // ...

  // 8. Let then be Get(resolution, "then").
  MaybeHandle<Object> then;
  if (isolate->IsPromiseThenLookupChainIntact(
          Handle<JSReceiver>::cast(resolution))) {
    // We can skip the "then" lookup on {resolution} if its [[Prototype]]
    // is the (initial) Promise.prototype and the Promise#then protector
    // is intact, as that guards the lookup path for the "then" property
    // on JSPromise instances which have the (initial) %PromisePrototype%.

    // 注意这里！这里调用了其他的then方法
    then = isolate->promise_then();
  } else {
    then =
        JSReceiver::GetProperty(isolate, Handle<JSReceiver>::cast(resolution),
                                isolate->factory()->then_string());
  }
  // ...

  // 10. Let thenAction be then.[[Value]].
  // 11. If IsCallable(thenAction) is false, then
  if (!then_action->IsCallable()) {
    // a. Return FulfillPromise(promise, resolution).
    // 这里调用Fulfill函数
    return Fulfill(promise, resolution);
  }
  // ...
}
```
注意该函数中部的isolate->promise_then()语句。如果resolution设置了其then属性，那么当控制流执行至此处时，就会调用用户所设计的getter。也就是说，在Promise Resoving执行到一半时，可以执行用户所定义的外部JS代码。

实际的用法：
为Object.prototype的then属性定义一个getter。从这时起，任何一个Promise中，从Object.prototype派生出的resolution都会调用这个getter。

```
Object.prototype.__defineGetter__("then", function() {
  // Statements
});
```

对于这类漏洞，我们可以通过Resolve去执行外部自定义的js代码，所以我们的关键就放在uaf的目标寻找上：

这里我们找到的是：
```
ScriptPromise DeflateTransformer::Transform(
    v8::Local<v8::Value> chunk,
    TransformStreamDefaultController* controller,
    ExceptionState& exception_state) {
  ArrayBufferOrArrayBufferView buffer_source;
  V8ArrayBufferOrArrayBufferView::ToImpl(
      script_state_->GetIsolate(), chunk, buffer_source,
      UnionTypeConversionMode::kNotNullable, exception_state);
  if (exception_state.HadException()) {
    return ScriptPromise();
  }
  if (buffer_source.IsArrayBufferView()) {
    const auto* view = buffer_source.GetAsArrayBufferView().View();
    const uint8_t* start = static_cast<const uint8_t*>(view->BaseAddress()); ------------------ [1]
    size_t length = view->byteLength();
    if (length > std::numeric_limits<wtf_size_t>::max()) {
      exception_state.ThrowRangeError(
          "Buffer size exceeds maximum heap object size.");
      return ScriptPromise();
    }
    Deflate(start, static_cast<wtf_size_t>(length), IsFinished(false), ------------------ [2]
            controller, exception_state);
    return ScriptPromise::CastUndefined(script_state_);
  }
  DCHECK(buffer_source.IsArrayBuffer());
  const auto* array_buffer = buffer_source.GetAsArrayBuffer();
  const uint8_t* start = static_cast<const uint8_t*>(array_buffer->Data());
  size_t length = array_buffer->ByteLength();
  if (length > std::numeric_limits<wtf_size_t>::max()) {
    exception_state.ThrowRangeError(
        "Buffer size exceeds maximum heap object size.");
    return ScriptPromise();
  }
  Deflate(start, static_cast<wtf_size_t>(length), IsFinished(false), controller,
          exception_state);

  return ScriptPromise::CastUndefined(script_state_);
}
```

首先是上面标注的[1]，可以看到在这里是获取到了ArrayBuffer的backing store的地址，之后把这里获取到的地址传入到了
```
Deflate(start, static_cast<wtf_size_t>(length), IsFinished(false),
            controller, exception_state);
```
函数中，也就是标注的[2]的位置。

我们接下来查看一下Deflate这个函数：
```
void DeflateTransformer::Deflate(const uint8_t* start,
                                 wtf_size_t length,
                                 IsFinished finished,
                                 TransformStreamDefaultController* controller,
                                 ExceptionState& exception_state) {
  stream_.avail_in = length;
  // Zlib treats this pointer as const, so this cast is safe.
  stream_.next_in = const_cast<uint8_t*>(start);

  do {
    stream_.avail_out = out_buffer_.size();
    stream_.next_out = out_buffer_.data();
    int err = deflate(&stream_, finished ? Z_FINISH : Z_NO_FLUSH);
    DCHECK((finished && err == Z_STREAM_END) || err == Z_OK ||
           err == Z_BUF_ERROR);

    wtf_size_t bytes = out_buffer_.size() - stream_.avail_out;
    if (bytes) { 
      controller->enqueue( ------------------ [3]
          script_state_,
          ScriptValue::From(script_state_,
                            DOMUint8Array::Create(out_buffer_.data(), bytes)),
          exception_state);
      if (exception_state.HadException()) {
        return;
      }
    }
  } while (stream_.avail_out == 0);
}
```
在该函数中，只要wtf_size_t bytes = out_buffer_.size() - stream_.avail_out;不为0，即满足if (bytes) 该判断将会去调用
```
controller->enqueue( 
          script_state_,
          ScriptValue::From(script_state_,
                            DOMUint8Array::Create(out_buffer_.data(), bytes)),
          exception_state);
```
接着我们就来看看他的代码：
```
void ReadableByteStreamController::Enqueue(
    ScriptState* script_state,
    ReadableByteStreamController* controller,
    NotShared<DOMArrayBufferView> chunk,
    ExceptionState& exception_state) {
  // https://streams.spec.whatwg.org/#readable-byte-stream-controller-enqueue
  // 1. Let stream be controller.[[stream]].i
  ReadableStream* const stream = controller->controlled_readable_stream_;

  // 2. If controller.[[closeRequested]] is true or stream.[[state]] is not
  // "readable", return.
  if (controller->close_requested_ ||
      stream->state_ != ReadableStream::kReadable) {
    return;
  }

  // 3. Let buffer be chunk.[[ViewedArrayBuffer]].
  DOMArrayBuffer* const buffer = chunk->buffer();

  // 4. Let byteOffset be chunk.[[ByteOffset]].
  const size_t byte_offset = chunk->byteOffset();

  // 5. Let byteLength be chunk.[[ByteLength]].
  const size_t byte_length = chunk->byteLength();

  // 6. Let transferredBuffer be ! TransferArrayBuffer(buffer).
  DOMArrayBuffer* const transferred_buffer =
      TransferArrayBuffer(script_state, buffer, exception_state);

  // 7. If ! ReadableStreamHasDefaultReader(stream) is true
  if (ReadableStream::HasDefaultReader(stream)) {
    //   a. If ! ReadableStreamGetNumReadRequests(stream) is 0,
    if (ReadableStream::GetNumReadRequests(stream) == 0) {
      //     i. Perform !
      //     ReadableByteStreamControllerEnqueueChunkToQueue(controller,
      //     transferredBuffer, byteOffset, byteLength).
      EnqueueChunkToQueue(controller, transferred_buffer, byte_offset,
                          byte_length);
    } else {
      // b. Otherwise,
      //     i. Assert: controller.[[queue]] is empty.
      DCHECK(controller->queue_.IsEmpty());
      //     ii. Let transferredView be ! Construct(%Uint8Array%, «
      //     transferredBuffer, byteOffset, byteLength »).
      v8::Local<v8::Value> const transferred_view = v8::Uint8Array::New(
          ToV8(transferred_buffer, script_state).As<v8::ArrayBuffer>(),
          byte_offset, byte_length);
      //     iii. Perform ! ReadableStreamFulfillReadRequest(stream,
      //     transferredView, false).
      ReadableStream::FulfillReadRequest(script_state, stream, transferred_view,
                                         false);
    }
  }


    ........  

}
```

当read请求已满时，即if (ReadableStream::GetNumReadRequests(stream) == 0)该判断不满足时，就会去调用ReadableStream::FulfillReadRequest，这个是该漏洞的关键函数：
```
void ReadableStream::FulfillReadRequest(ScriptState* script_state,
                                        ReadableStream* stream,
                                        v8::Local<v8::Value> chunk,
                                        bool done) {
  // https://streams.spec.whatwg.org/#readable-stream-fulfill-read-request
  // 1. Assert: ! ReadableStreamHasDefaultReader(stream) is true.
  DCHECK(HasDefaultReader(stream));

  // 2. Let reader be stream.[[reader]].
  ReadableStreamGenericReader* reader = stream->reader_;
  ReadableStreamDefaultReader* default_reader =
      To<ReadableStreamDefaultReader>(reader);

  // 3. Let readRequest be the first element of reader.[[readRequests]].
  StreamPromiseResolver* read_request = default_reader->read_requests_.front();

  // 4. Remove readIntoRequest from reader.[[readIntoRequests]], shifting all
  //    other elements downward (so that the second becomes the first, and so
  //    on).
  default_reader->read_requests_.pop_front();

  // 5. Resolve readIntoRequest.[[promise]] with !
  //    ReadableStreamCreateReadResult(chunk, done, reader.[[forAuthorCode]]).
  read_request->Resolve(script_state, ReadableStream::CreateReadResult(
                                          script_state, chunk, done,
                                          default_reader->for_author_code_));
}
```
在该函数中就调用了我们一直提到的read_request->Resolve，我们只要在then中将arraybuffer释放掉即可去触发uaf。