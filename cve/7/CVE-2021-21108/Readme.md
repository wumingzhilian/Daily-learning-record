CVE-2021-21108是由于析构TabSharingUIViews时如果infobars_为空则会导致observers_未被清理，最终导致uaf

首先我们为了达到infobars_为空的条件，就需要找到可以删除其中元素的功能，这时我们注意到了TabSharingUIViews::OnInfoBarRemoved这个函数：

```
void TabSharingUIViews::OnInfoBarRemoved(infobars::InfoBar* infobar,
                                         bool animate) {
  auto infobars_entry = std::find_if(infobars_.begin(), infobars_.end(),
                                     [infobar](const auto& infobars_entry) {
                                       return infobars_entry.second == infobar;
                                     });
  if (infobars_entry == infobars_.end())
    return;

  infobar->owner()->RemoveObserver(this);
  infobars_.erase(infobars_entry);
  if (InfoBarService::WebContentsFromInfoBar(infobar) == shared_tab_)
    StopSharing();
}
```
可以看到其中执行了infobars_.erase(infobars_entry);利用它我们可以使infobars_为空。

其次，我们需要添加一些observe以供uaf的产生：
这里有一个调用链：MediaStreamUIProxy::OnStarted() -> MediaStreamUIProxy::Core::OnStarted() -> gfx::NativeViewId OnStarted()
 -> TabSharingUIViews::OnStarted()
```
void MediaStreamUIProxy::OnStarted(
    base::OnceClosure stop_callback,
    MediaStreamUI::SourceCallback source_callback,
    WindowIdCallback window_id_callback,
    const std::string& label,
    std::vector<DesktopMediaID> screen_share_ids,
    MediaStreamUI::StateChangeCallback state_change_callback) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  stop_callback_ = std::move(stop_callback);
  source_callback_ = std::move(source_callback);
  state_change_callback_ = std::move(state_change_callback);

  // Owned by the PostTaskAndReply callback.
  gfx::NativeViewId* window_id = new gfx::NativeViewId(0);

  GetUIThreadTaskRunner({})->PostTaskAndReply(
      FROM_HERE,
      base::BindOnce(&Core::OnStarted, base::Unretained(core_.get()), window_id,
                     !!source_callback_, label, screen_share_ids),
      base::BindOnce(&MediaStreamUIProxy::OnWindowId,
                     weak_factory_.GetWeakPtr(), std::move(window_id_callback),
                     base::Owned(window_id)));
}


void MediaStreamUIProxy::Core::OnStarted(
    gfx::NativeViewId* window_id,
    bool has_source_callback,
    const std::string& label,
    std::vector<DesktopMediaID> screen_share_ids) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);

  if (!ui_)
    return;

  MediaStreamUI::SourceCallback device_change_cb;
  if (has_source_callback) {
    device_change_cb =
        base::BindRepeating(&Core::ProcessChangeSourceRequestFromUI,
                            weak_factory_for_ui_.GetWeakPtr());
  }

  *window_id =
      ui_->OnStarted(base::BindOnce(&Core::ProcessStopRequestFromUI,
                                    weak_factory_for_ui_.GetWeakPtr()),
                     device_change_cb, label, screen_share_ids,
                     base::BindRepeating(&Core::ProcessStateChangeFromUI,
                                         weak_factory_for_ui_.GetWeakPtr()));
}

void MediaStreamUIProxy::Core::OnDeviceStopped(const std::string& label,
                                               const DesktopMediaID& media_id) {
  if (ui_) {
    ui_->OnDeviceStopped(label, media_id);
  }
}
```
MediaStreamUIProxy::Core::OnStarted()中*window_id = ui_->OnStarted处调用了gfx::NativeViewId OnStarted()
```
  gfx::NativeViewId OnStarted(
      base::OnceClosure stop_callback,
      content::MediaStreamUI::SourceCallback source_callback,
      const std::string& label,
      std::vector<content::DesktopMediaID> screen_capture_ids,
      StateChangeCallback state_change_callback) override {
    started_ = true;

    if (device_usage_) {
      // |device_usage_| handles |stop_callback| when |ui_| is unspecified.
      device_usage_->AddDevices(
          devices_, ui_ ? base::OnceClosure() : std::move(stop_callback));
    }

#if BUILDFLAG(IS_CHROMEOS_ASH)
    policy::DlpContentManager::Get()->OnScreenCaptureStarted(
        label, screen_capture_ids, application_title_, state_change_callback);
#endif

    // If a custom |ui_| is specified, notify it that the stream started and let
    // it handle the |stop_callback| and |source_callback|.
    if (ui_)
      return ui_->OnStarted(std::move(stop_callback),
                            std::move(source_callback));

    return 0;
  }
```
gfx::NativeViewId OnStarted()中ui\_->OnStarted处调用了gfx::NativeViewId TabSharingUIViews::OnStarted

```
gfx::NativeViewId TabSharingUIViews::OnStarted(
    base::OnceClosure stop_callback,
    content::MediaStreamUI::SourceCallback source_callback) {
  source_callback_ = std::move(source_callback);
  stop_callback_ = std::move(stop_callback);
  CreateInfobarsForAllTabs();
  SetContentsBorderVisible(shared_tab_, true);
  CreateTabCaptureIndicator();
  return 0;
}
```
在gfx::NativeViewId TabSharingUIViews::OnStarted中调用了CreateInfobarsForAllTabs()函数，我们来看看他的实现：

```
void TabSharingUIViews::CreateInfobarsForAllTabs() {
  BrowserList* browser_list = BrowserList::GetInstance();
  for (auto* browser : *browser_list) {
    OnBrowserAdded(browser);

    TabStripModel* tab_strip_model = browser->tab_strip_model();
    for (int i = 0; i < tab_strip_model->count(); i++) {
      CreateInfobarForWebContents(tab_strip_model->GetWebContentsAt(i));
    }
  }
  browser_list->AddObserver(this);
}
```
可以看到在CreateInfobarsForAllTabs函数中执行了browser_list->AddObserver(this);，他将向browser_list添加Observer。

之后如果我们手动关闭共享选项卡，将会触发共享选项卡相关类的析构函数，其中就包括了~TabSharingUIViews：
```
TabSharingUIViews::~TabSharingUIViews() {
  if (!infobars_.empty())
    StopSharing();
}
```

可以看到当infobars_.empty()满足时就会直接执行StopSharing()，这就会导致Observer虽然已被析构，但任然存留。

最后就是uaf的产生了：

```
void BrowserList::RemoveBrowser(Browser* browser) {
  // Remove |browser| from the appropriate list instance.
  BrowserList* browser_list = GetInstance();
  RemoveBrowserFrom(browser, &browser_list->last_active_browsers_);
  browser_list->currently_closing_browsers_.erase(browser);

  RemoveBrowserFrom(browser, &browser_list->browsers_);

  for (BrowserListObserver& observer : observers_.Get())
    observer.OnBrowserRemoved(browser);

  browser->UnregisterKeepAlive();

  // If we're exiting, send out the APP_TERMINATING notification to allow other
  // modules to shut themselves down.
  if (chrome::GetTotalBrowserCount() == 0 &&
      (browser_shutdown::IsTryingToQuit() ||
       g_browser_process->IsShuttingDown())) {
    // Last browser has just closed, and this is a user-initiated quit or there
    // is no module keeping the app alive, so send out our notification. No need
    // to call ProfileManager::ShutdownSessionServices() as part of the
    // shutdown, because Browser::WindowClosing() already makes sure that the
    // SessionService is created and notified.
    browser_shutdown::NotifyAppTerminating();
    chrome::OnAppExiting();
  }
}
```
BrowserList::RemoveBrowser函数会执行observer.OnBrowserRemoved(browser);，他将会把OnBrowserRemoved的执行结果存入observer，但observe已经被析构，所以导致了uaf的产生。