在P2PSocketDispatcher对象中，p2p_socket_manager_作为SharedRemote被管理，在P2PSocketDispatcher的构造函数中将会使p2p_socket_manager_保持alive
```
class PLATFORM_EXPORT P2PSocketDispatcher
    : public GarbageCollected<P2PSocketDispatcher>,
      public Supplement<MojoBindingContext>,
      public blink::NetworkListManager,
      public network::mojom::blink::P2PNetworkNotificationClient {
 public:
  static const char kSupplementName[];

  static P2PSocketDispatcher& From(MojoBindingContext& context);

  P2PSocketDispatcher(MojoBindingContext& context,
                      base::PassKey<P2PSocketDispatcher>);
  P2PSocketDispatcher(const P2PSocketDispatcher&) = delete;
  P2PSocketDispatcher& operator=(const P2PSocketDispatcher&) = delete;
  ~P2PSocketDispatcher() override;

  // blink::NetworkListManager interface:
  void AddNetworkListObserver(
      blink::NetworkListObserver* network_list_observer) override;
  void RemoveNetworkListObserver(
      blink::NetworkListObserver* network_list_observer) override;

  mojo::SharedRemote<network::mojom::blink::P2PSocketManager>
  GetP2PSocketManager();

  void Trace(Visitor*) const override;

 private:
  // network::mojom::blink::P2PNetworkNotificationClient interface.
  void NetworkListChanged(
      const Vector<net::NetworkInterface>& networks,
      const net::IPAddress& default_ipv4_local_address,
      const net::IPAddress& default_ipv6_local_address) override;

  void RequestInterfaceIfNecessary();
  void RequestNetworkEventsIfNecessary();

  void OnConnectionError();
  void ReconnectP2PSocketManager();

  scoped_refptr<base::SingleThreadTaskRunner> main_task_runner_;

  // TODO(crbug.com/787254): When moving NetworkListObserver to Oilpan,
  // thread-safety needs to be taken into account.
  scoped_refptr<base::ObserverListThreadSafe<blink::NetworkListObserver>>
      network_list_observers_;

  mojo::PendingReceiver<network::mojom::blink::P2PSocketManager>
      p2p_socket_manager_receiver_;
  mojo::SharedRemote<network::mojom::blink::P2PSocketManager>
      p2p_socket_manager_ GUARDED_BY(p2p_socket_manager_lock_);
  base::Lock p2p_socket_manager_lock_;

  // Cached from last |NetworkListChanged| call.
  Vector<net::NetworkInterface> networks_;
  net::IPAddress default_ipv4_local_address_;
  net::IPAddress default_ipv6_local_address_;

  HeapMojoReceiver<network::mojom::blink::P2PNetworkNotificationClient,
                   P2PSocketDispatcher>
      network_notification_client_receiver_;
};
```

但是在出现mojo错误的时候，P2PSocketDispatcher将会重置p2p_socket_manager_，具体如下：
```
void P2PSocketDispatcher::OnConnectionError() {
  base::AutoLock lock(p2p_socket_manager_lock_);
  p2p_socket_manager_.reset();
  // Attempt to reconnect in case the network service crashed in his being
  // restarted.
  PostCrossThreadTask(
      *main_task_runner_.get(), FROM_HERE,
      CrossThreadBindOnce(&P2PSocketDispatcher::ReconnectP2PSocketManager,
                          WrapCrossThreadWeakPersistent(this)));
}
```
可以看到在ConnectionError的时候会去调用p2p_socket_manager_.reset();

这里有个很有意思的点：
因为p2p_socket_manager_是通过SharedRemote来管理的，所以这里的reset操作时需要获取锁的：
```
base::AutoLock lock(p2p_socket_manager_lock_);
p2p_socket_manager_.reset();
```

漏洞的关键来了：
```
network::mojom::blink::P2PSocketManager*
P2PSocketDispatcher::GetP2PSocketManager() {
  base::AutoLock lock(p2p_socket_manager_lock_);
  if (!p2p_socket_manager_) {
    mojo::PendingRemote<network::mojom::blink::P2PSocketManager>
        p2p_socket_manager;
    p2p_socket_manager_receiver_ =
        p2p_socket_manager.InitWithNewPipeAndPassReceiver();
    p2p_socket_manager_ =
        mojo::SharedRemote<network::mojom::blink::P2PSocketManager>(
            std::move(p2p_socket_manager));
    p2p_socket_manager_.set_disconnect_handler(
        WTF::Bind(&P2PSocketDispatcher::OnConnectionError,
                  WTF::Unretained(this)),
        main_task_runner_);
  }
  PostCrossThreadTask(
      *main_task_runner_.get(), FROM_HERE,
      CrossThreadBindOnce(&P2PSocketDispatcher::RequestInterfaceIfNecessary,
                          scoped_refptr<P2PSocketDispatcher>(this)));
  return p2p_socket_manager_.get();
}
```
可以看到GetP2PSocketManager()在获取p2p_socket_manager_的时候也获取了锁，但是这里需要注意他的返回值：network::mojom::blink::P2PSocketManager*，它返回了一个实际指针，我们接下来看下这个实际指针将会被传递到何处：

这里有两个函数：
```
void P2PSocketClientImpl::Init(
    network::P2PSocketType type,
    const net::IPEndPoint& local_address,
    uint16_t min_port,
    uint16_t max_port,
    const network::P2PHostAndIPEndPoint& remote_address,
    blink::P2PSocketClientDelegate* delegate) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(delegate);
  // |delegate_| is only accessesed on |delegate_message_loop_|.
  delegate_ = delegate;

  DCHECK_EQ(state_, STATE_UNINITIALIZED);
  state_ = STATE_OPENING;
  dispatcher_->GetP2PSocketManager()->CreateSocket(
      type, local_address, network::P2PPortRange(min_port, max_port),
      remote_address, receiver_.BindNewPipeAndPassRemote(),
      socket_.BindNewPipeAndPassReceiver());
  receiver_.set_disconnect_handler(WTF::Bind(
      &P2PSocketClientImpl::OnConnectionError, WTF::Unretained(this)));
}

void P2PAsyncAddressResolver::Start(const rtc::SocketAddress& host_name,
                                    DoneCallback done_callback) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK_EQ(STATE_CREATED, state_);

  state_ = STATE_SENT;
  done_callback_ = std::move(done_callback);
  bool enable_mdns = base::FeatureList::IsEnabled(
      blink::features::kWebRtcHideLocalIpsWithMdns);
  dispatcher_->GetP2PSocketManager()->GetHostAddress(
      String(host_name.hostname().data()), enable_mdns,
      WTF::Bind(&P2PAsyncAddressResolver::OnResponse,
                scoped_refptr<P2PAsyncAddressResolver>(this)));
}
```
道理都是一样的，我们就以P2PSocketClientImpl::Init为例进行分析，可以看到在dispatcher_->GetP2PSocketManager()这里获得了P2PSocketManager的实际指针，而不持有SharedRemote的引用，这就导致它没有持有保护SharedRemote的锁

结合上面的内容我们就可以想到：OnConnectionError()中删除的p2p_socket_manager_将会在P2PSocketClientImpl::Init被使用导致uaf。
