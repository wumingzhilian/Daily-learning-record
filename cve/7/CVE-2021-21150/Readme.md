在windows的chrome中有一个功能：drag and drop download，在该功能中DragDownloadFileUI存储了WebContents的实际指针，这将导致其生命周期超出DragDownloadFileUI，即在DragDownloadFileUI析构后仍可使用，最终导致uaf的产生。

首先是一段准备阶段代码：
```
void PrepareDragData(const DropData& drop_data,
                     ui::OSExchangeDataProvider* provider,
                     WebContentsImpl* web_contents) {
  provider->MarkOriginatedFromRenderer();
#if defined(OS_WIN)
  // Put download before file contents to prefer the download of a image over
  // its thumbnail link.
  if (!drop_data.download_metadata.empty())
    PrepareDragForDownload(drop_data, provider, web_contents);
#endif
#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_WIN)
  // We set the file contents before the URL because the URL also sets file
  // contents (to a .URL shortcut).  We want to prefer file content data over
  // a shortcut so we add it first.
  if (!drop_data.file_contents.empty())
    PrepareDragForFileContents(drop_data, provider);
#endif
  // Call SetString() before SetURL() when we actually have a custom string.
  // SetURL() will itself do SetString() when a string hasn't been set yet,
  // but we want to prefer drop_data.text.string() over the URL string if it
  // exists.
  if (drop_data.text && !drop_data.text->empty())
    provider->SetString(*drop_data.text);
  if (drop_data.url.is_valid())
    provider->SetURL(drop_data.url, drop_data.url_title);
  if (drop_data.html && !drop_data.html->empty())
    provider->SetHtml(*drop_data.html, drop_data.html_base_url);
  if (!drop_data.filenames.empty())
    provider->SetFilenames(drop_data.filenames);
  if (!drop_data.file_system_files.empty()) {
    base::Pickle pickle;
    DropData::FileSystemFileInfo::WriteFileSystemFilesToPickle(
        drop_data.file_system_files, &pickle);
    provider->SetPickledData(GetFileSystemFileFormatType(), pickle);
  }
  if (!drop_data.custom_data.empty()) {
    base::Pickle pickle;
    ui::WriteCustomDataToPickle(drop_data.custom_data, &pickle);
    provider->SetPickledData(ui::ClipboardFormatType::GetWebCustomDataType(),
                             pickle);
  }
}
```
其中的PrepareDragForDownload函数为drag and drop download的实现做准备。

drag and drop download是在UI进程中异步执行的，我们接下来就来看看该功能的开始阶段：
```
HRESULT DataObjectImpl::GetData(FORMATETC* format_etc, STGMEDIUM* medium) {
  if (is_aborting_)
    return DV_E_FORMATETC;

  for (const std::unique_ptr<StoredDataInfo>& content : contents_) {
    if (content->format_etc.cfFormat == format_etc->cfFormat &&
        content->format_etc.lindex == format_etc->lindex &&
        (content->format_etc.tymed & format_etc->tymed)) {
      // If medium is NULL, delay-rendering will be used.
      if (content->medium.tymed != TYMED_NULL) {
        *medium =
            DuplicateMedium(content->format_etc.cfFormat, content->medium);
        return S_OK;
      }
      // Fail all GetData() attempts for DownloadURL data if the drag and drop
      // operation is still in progress.
      if (in_drag_loop_)
        return DV_E_FORMATETC;

      bool wait_for_data = false;

      // In async mode, we do not want to start waiting for the data before
      // the async operation is started. This is because we want to postpone
      // until Shell kicks off a background thread to do the work so that
      // we do not block the UI thread.
      if (!in_async_mode_ || async_operation_started_)
        wait_for_data = true;

      if (!wait_for_data)
        return DV_E_FORMATETC;

      // Now we can start the download.
      if (content->downloader.get()) {
        content->downloader->Start(this);
        if (!content->downloader->Wait()) {
          is_aborting_ = true;
          return DV_E_FORMATETC;
        }
      }
      // The stored data should have been updated with the final version.
      // So we just need to call this function again to retrieve it.
      return GetData(format_etc, medium);
    }
  }

  return DV_E_FORMATETC;
}
```
首先通过GetData去获取要下载的内容，之后通过content->downloader->Start(this);来启动下载。

```
void DragDownloadFile::Start(ui::DownloadFileObserver* observer) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);

  if (state_ != INITIALIZED)
    return;
  state_ = STARTED;

  DCHECK(!observer_.get());
  observer_ = observer;
  DCHECK(observer_.get());

  GetUIThreadTaskRunner({})->PostTask(
      FROM_HERE,
      base::BindOnce(&DragDownloadFileUI::InitiateDownload,
                     base::Unretained(drag_ui_), std::move(file_), file_path_));
}
```

我们通过观察DragDownloadFile类，可以发现DragDownloadFileUI* drag_ui_，即在该类中保存了DragDownloadFileUI的实际指针。
```
class CONTENT_EXPORT DragDownloadFile : public ui::DownloadFileProvider {
 public:
  // On Windows, we need to download into a temporary file. On posix, we need to
  // download into a file that has already been created, so only the UI
  // thread is involved. |file| must be null on windows but non-null on
  // posix systems. |file_path| is an absolute path on all systems.
  DragDownloadFile(const base::FilePath& file_path,
                   base::File file,
                   const GURL& url,
                   const Referrer& referrer,
                   const std::string& referrer_encoding,
                   WebContents* web_contents);
  ~DragDownloadFile() override;

  // DownloadFileProvider methods.
  void Start(ui::DownloadFileObserver* observer) override;
  bool Wait() override;
  void Stop() override;

 private:
  class DragDownloadFileUI;
  enum State {INITIALIZED, STARTED, SUCCESS, FAILURE};

  void DownloadCompleted(bool is_successful);
  void CheckThread();

  base::FilePath file_path_;
  base::File file_;
  State state_ = INITIALIZED;
  scoped_refptr<ui::DownloadFileObserver> observer_;
  base::RunLoop nested_loop_;
  DragDownloadFileUI* drag_ui_ = nullptr;
  base::WeakPtrFactory<DragDownloadFile> weak_ptr_factory_{this};

  DISALLOW_COPY_AND_ASSIGN(DragDownloadFile);
};
```

但是这里其实是不会触发漏洞的，这是因为InitiateDownload执行之后他将会去调用~DragDownloadFile去析构掉DragDownloadFileUI。
~DragDownloadFile是唯一可以删除 drag_ui_ 的地方，它向 UI 线程发布一条消息，以便它在正确的线程上调用 RemoveObserver。

```
DragDownloadFile::~DragDownloadFile() {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);

  // This is the only place that drag_ui_ can be deleted from. Post a message to
  // the UI thread so that it calls RemoveObserver on the right thread, and so
  // that this task will run after the InitiateDownload task runs on the UI
  // thread.
  GetUIThreadTaskRunner({})->PostTask(
      FROM_HERE,
      base::BindOnce(&DragDownloadFileUI::Delete, base::Unretained(drag_ui_)));
  drag_ui_ = nullptr;
}
```
由于DragDownloadFileUI他的生命周期过于短，所以并不会存在超过DragDownloadFile的情况，但是其他指针就不是这么幸运了，我们接着往下看：

```
class DragDownloadFile::DragDownloadFileUI
    : public download::DownloadItem::Observer {
 
 .....

  OnCompleted on_completed_;
  GURL url_;
  Referrer referrer_;
  std::string referrer_encoding_;
  WebContents* web_contents_;
  download::DownloadItem* download_item_ = nullptr;

  // Only used in the callback from DownloadManager::DownloadUrl().
  base::WeakPtrFactory<DragDownloadFileUI> weak_ptr_factory_{this};

  DISALLOW_COPY_AND_ASSIGN(DragDownloadFileUI);
};
```
这里可以看到DragDownloadFileUI保存了WebContents* web_contents_;即WebContents的实际指针，而WebContents可以在InitiateDownload调用之前被释放
但是在InitiateDownload中
```
std::unique_ptr<download::DownloadUrlParameters> params(
        DownloadRequestUtils::CreateDownloadForWebContentsMainFrame(
            web_contents_, url_, traffic_annotation));
```
使用到了web_contents\_，最终导致了uaf的产生。