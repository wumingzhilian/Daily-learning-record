这个漏洞是和PaymentRequest模块有关的，我们先来理一下这个支付流程：
当用户点击支付按钮时，将会调用GeneratePaymentResponse()。具体如下：
```
void PaymentRequestState::GeneratePaymentResponse() {
  DCHECK(is_ready_to_pay());

  if (!spec_)
    return;

  // Once the response is ready, will call back into OnPaymentResponseReady.
  response_helper_ = std::make_unique<PaymentResponseHelper>(
      app_locale_, spec_, selected_app_, payment_request_delegate_,
      selected_shipping_profile_, selected_contact_profile_,
      weak_ptr_factory_.GetWeakPtr());
}
```

可以看到在这个函数中创建了一个PaymentResponseHelper对象，这里是漏洞的关键，我们来看一下他的成员：

```
class PaymentResponseHelper
    : public PaymentApp::Delegate,
      public base::SupportsWeakPtr<PaymentResponseHelper> {
 public:
  class Delegate {
   public:
    virtual ~Delegate() {}

    virtual void OnPaymentResponseReady(
        mojom::PaymentResponsePtr payment_response) = 0;

    virtual void OnPaymentResponseError(const std::string& error_message) = 0;
  };

  // The spec, selected_app and delegate cannot be null.
  PaymentResponseHelper(const std::string& app_locale,
                        PaymentRequestSpec* spec,
                        PaymentApp* selected_app,
                        PaymentRequestDelegate* payment_request_delegate,
                        autofill::AutofillProfile* selected_shipping_profile,
                        autofill::AutofillProfile* selected_contact_profile,
                        Delegate* delegate);
  ~PaymentResponseHelper() override;

  // PaymentApp::Delegate
  void OnInstrumentDetailsReady(const std::string& method_name,
                                const std::string& stringified_details,
                                const PayerData& payer_data) override;
  void OnInstrumentDetailsError(const std::string& error_message) override;

  mojom::PayerDetailPtr GeneratePayerDetail(
      const autofill::AutofillProfile* selected_contact_profile) const;

 private:
  // Generates the Payment Response and sends it to the delegate.
  void GeneratePaymentResponse();

  // To be used as AddressNormalizer::NormalizationCallback.
  void OnAddressNormalized(bool success,
                           const autofill::AutofillProfile& normalized_profile);

  const std::string& app_locale_;
  bool is_waiting_for_shipping_address_normalization_;
  bool is_waiting_for_instrument_details_;

  // Not owned, cannot be null.
  PaymentRequestSpec* spec_;
  Delegate* delegate_;
  PaymentApp* selected_app_;  <-------!!!! 漏洞点
  PaymentRequestDelegate* payment_request_delegate_;

  // Not owned, can be null (dependent on the spec).
  autofill::AutofillProfile* selected_contact_profile_;

  // A normalized copy of the shipping address, which will be included in the
  // PaymentResponse.
  autofill::AutofillProfile shipping_address_;

  // Instrument Details.
  std::string method_name_;
  std::string stringified_details_;

  // Details from payment handler response that will be included in the
  // PaymentResponse when shipping/contact handling is delegated to the payment
  // handler.
  PayerData payer_data_from_app_;

  base::WeakPtrFactory<PaymentResponseHelper> weak_ptr_factory_{this};

  DISALLOW_COPY_AND_ASSIGN(PaymentResponseHelper);
};
```

具体的漏洞点已经注释标出，可以看到在PaymentResponseHelper中直接存储了PaymentApp的实际指针，从之前的几个uaf漏洞中也可以感受到这是非常危险的行为。
```
PaymentApp* selected_app_;
```

接下来我们来看一下他的构造函数：
```
PaymentResponseHelper::PaymentResponseHelper(
    const std::string& app_locale,
    base::WeakPtr<PaymentRequestSpec> spec,
    PaymentApp* selected_app,
    PaymentRequestDelegate* payment_request_delegate,
    autofill::AutofillProfile* selected_shipping_profile,
    autofill::AutofillProfile* selected_contact_profile,
    base::WeakPtr<Delegate> delegate)
    : app_locale_(app_locale),
      is_waiting_for_shipping_address_normalization_(false),
      is_waiting_for_instrument_details_(false),
      spec_(spec),
      delegate_(delegate),
      selected_app_(selected_app),
      payment_request_delegate_(payment_request_delegate),
      selected_contact_profile_(selected_contact_profile) {
  DCHECK(selected_app_);
  DCHECK(delegate_);

  is_waiting_for_instrument_details_ = true;

  // Start to normalize the shipping address, if necessary.
  if (spec_->request_shipping() && !selected_app_->HandlesShippingAddress()) {
    DCHECK(selected_shipping_profile);
    DCHECK(spec_->selected_shipping_option());

    is_waiting_for_shipping_address_normalization_ = true;

    payment_request_delegate_->GetAddressNormalizer()->NormalizeAddressAsync(
        *selected_shipping_profile,
        /*timeout_seconds=*/5,
        base::BindOnce(&PaymentResponseHelper::OnAddressNormalized,
                       weak_ptr_factory_.GetWeakPtr()));
  }

  // Start to get the instrument details. Will call back into
  // OnInstrumentDetailsReady.
  selected_app_->InvokePaymentApp(this);
}
```
这里有一个需要注意的地方：
```
payment_request_delegate_->GetAddressNormalizer()->NormalizeAddressAsync(
        *selected_shipping_profile,
        /*timeout_seconds=*/5,
        base::BindOnce(&PaymentResponseHelper::OnAddressNormalized,
                       weak_ptr_factory_.GetWeakPtr()));
```
在这里发送了一个请求去规范化送货地址，并且设置了超时5秒，这意味着当超时或者成功规范送货地址之后，将会去调用PaymentResponseHelper::OnAddressNormalized。

我们来看一下OnAddressNormalized函数：
```
void PaymentResponseHelper::OnAddressNormalized(
    bool success,
    const autofill::AutofillProfile& normalized_profile) {
  if (!is_waiting_for_shipping_address_normalization_)
    return;

  shipping_address_ = normalized_profile;
  is_waiting_for_shipping_address_normalization_ = false;

  if (!is_waiting_for_instrument_details_)
    GeneratePaymentResponse();
}
```
它会去调用GeneratePaymentResponse()函数
```
void PaymentResponseHelper::GeneratePaymentResponse() {
  DCHECK(!is_waiting_for_instrument_details_);
  DCHECK(!is_waiting_for_shipping_address_normalization_);

  if (!spec_)
    return;

  mojom::PaymentResponsePtr payment_response = mojom::PaymentResponse::New();

  // Make sure that we return the method name that the merchant specified for
  // this app: cards can be either specified through their name (e.g., "visa")
  // or through basic-card's supportedNetworks.
  payment_response->method_name =
      spec_->IsMethodSupportedThroughBasicCard(method_name_)
          ? methods::kBasicCard
          : method_name_;
  payment_response->stringified_details = stringified_details_;

  // Shipping Address section
  if (spec_->request_shipping()) {
    if (selected_app_->HandlesShippingAddress()) {
      payment_response->shipping_address =
          std::move(payer_data_from_app_.shipping_address);
      payment_response->shipping_option =
          payer_data_from_app_.selected_shipping_option_id;
    } else {
      payment_response->shipping_address =
          data_util::GetPaymentAddressFromAutofillProfile(shipping_address_,
                                                          app_locale_);
      payment_response->shipping_option = spec_->selected_shipping_option()->id;
    }
  }

  // Contact Details section.
  payment_response->payer = GeneratePayerDetail(selected_contact_profile_);

  delegate_->OnPaymentResponseReady(std::move(payment_response));
}
```
在该函数中调用了slected_app_中的虚函数：if (selected_app_->HandlesShippingAddress())
我们再来回忆一下这个slected_app_，PaymentResponseHelper中保存了他的实际指针，我们如果可以在这个调用虚函数之前去释放掉它的指针就会导致uaf，那我们来思考一下如何实现它：

小结一下上面的已知情报我们可以发现：
在调用OnAddressNormalized之前有一个5秒的超时，我们只要能在这5秒里将slected_app_给释放掉即可触发uaf。

这里我们找到了一种释放它的方法：
```
void PaymentRequest::Retry(mojom::PaymentValidationErrorsPtr errors) {
  if (!IsInitialized()) {
    log_.Error(errors::kCannotRetryWithoutInit);
    TerminateConnection();
    return;
  }

  if (!IsThisPaymentRequestShowing()) {
    log_.Error(errors::kCannotRetryWithoutShow);
    TerminateConnection();
    return;
  }

  std::string error;
  if (!PaymentsValidators::IsValidPaymentValidationErrorsFormat(errors,
                                                                &error)) {
    log_.Error(error);
    client_->OnError(mojom::PaymentErrorReason::USER_CANCEL, error);
    TerminateConnection();
    return;
  }

  VLOG(2) << "PaymentRequest (" << *spec_->details().id
          << ") retry with error: " << error;

  state()->SetAvailablePaymentAppForRetry();
  spec()->Retry(std::move(errors));
  display_handle_->Retry();
}
```
那就是PaymentRequest::Retry，在该函数中会调用SetAvailablePaymentAppForRetry()

```
void PaymentRequestState::SetAvailablePaymentAppForRetry() {
  DCHECK(selected_app_);
  base::EraseIf(available_apps_, [this](const auto& payment_app) {
    // Remove the app if it is not selected.
    return payment_app.get() != selected_app_;
  });
  is_retry_called_ = true;
}
```
我们可以看到在这里有一个Remove app的操作，但是它只会释放未select的app，要怎么去释放当前select的去调用虚函数的app呢，这就需要我们进行两次支付，在第二次支付时第一次select的并没有被选择，所以可以在第二次支付中通过retry将app释放，这一切只要在5秒内实现就可以触发uaf。
