base::MessageLoop 代表消息循环，它不会主动创建新的线程，默认情况下它使用当前线程（你也可以手动把它 Bind 到指定的线程上）。

它只负责消息（任务）循环，它提供了 task_runner() 方法用于获取 TaskRunner 对象，你需要使用 TaskRunner::PostTask*() 方法来向该消息循环分发消息，默认情况下这些消息（任务）会在当前线程运行。

因此，你可以在当前线程中创建 MessageLoop 并且在当前线程中向它 Post 消息，并且这些消息（任务）会在当前线程执行。

每一个通过base::Thread创建出来的线程都拥有一个 MessageLoop，但是主线程（main 函数所在的线程）不是通过base::Thread来创建的，它又需要处理消息循环，因此需要手动给主线程创建MessageLoop，这个过程一般在程序的入口处进行。

你可以使用 base::MessageLoopCurrent::Get()静态方法获取当前线程的MessageLoop对象，从而使用 base::MessageLoopCurrent::Get()->task_runner()->PostTask*()方法来创建任务。

一旦你创建了一个MessageLoop对象，它会自动Bind到当前线程（通过线程依赖的ThreadLocal机制来实现）。

这种每个线程包含一个 MessageLoop 的机制称为 单线程异步多任务 机制，可以理解为一种设计模式，在很多框架中都会使用，典型的比如网页中 js 的执行虽然可以是异步的，但是都在同一个线程中，还有包括 WPF 的 Dispatcher 机制，Android 的 Looper 机制等。这种机制可以大大简化线程的使用复杂度。一般通用线程池的任务队列也使用这种机制。

常规的使用方式如下：
```
#include "base/logging.h"
#include "base/message_loop/message_loop.h"
#include "base/message_loop/message_loop_current.h"
#include "base/task/post_task.h"
#include "base/task/single_thread_task_executor.h"
#include "base/task/thread_pool/thread_pool_impl.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/threading/thread_task_runner_handle.h"
#include "base/timer/timer.h"

void Hello() {
  LOG(INFO) << "hello,demo!";
}

int main(int argc, char** argv) {
  // 创建消息循环
  base::MessageLoop message_loop;
  // 也可以使用下面的方法。它们的区别仅在于 MessageLoop 对外暴露了更多的内部接口。
  // 在当前线程创建一个可执行 task 的环境，同样需要使用 RunLoop 启动
  // base::SingleThreadTaskExecutor main_task_executer;

  base::RunLoop run_loop;

  // 使用 message_loop 对象直接创建任务
  message_loop.task_runner()->PostTask(FROM_HERE, base::BindOnce(&Hello));
  // 获取当前线程的 task runner
  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE,
                                                base::BindOnce(&Hello));

  // 启动消息循环，即使没有任务也会阻塞程序运行。当前进程中只有一个线程。
  run_loop.Run();

  return 0;
}

```


简单总接一下就是：MessageLoop 创建消息/任务循环，并且绑定到当前线程，RunLoop 启动消息循环，调用者通过 TaskRunner 来创建任务

当用户的书签数量超过15个时，再选择打开所有标签页时，会弹出一个确认窗口，下面我们来看一下这个窗口的创建过程：
```
void OpenAll(gfx::NativeWindow parent,
             content::PageNavigator* navigator,
             const std::vector<const BookmarkNode*>& nodes,
             WindowOpenDisposition initial_disposition,
             content::BrowserContext* browser_context) {
  if (!ShouldOpenAll(parent, nodes))
    return;

  // Opens all |nodes| of type URL and any children of |nodes| that are of type
  // URL. |navigator| is the PageNavigator used to open URLs. After the first
  // url is opened |navigator| is set to the PageNavigator of the last active
  // tab. This is done to handle a window disposition of new window, in which
  // case we want subsequent tabs to open in that window.

  std::vector<GURL> urls = GetURLsToOpen(
      nodes, browser_context,
      initial_disposition == WindowOpenDisposition::OFF_THE_RECORD);

  WindowOpenDisposition disposition = initial_disposition;
  for (std::vector<GURL>::const_iterator url_it = urls.begin();
       url_it != urls.end(); ++url_it) {
    content::WebContents* opened_tab = navigator->OpenURL(
        content::OpenURLParams(*url_it, content::Referrer(), disposition,
                               ui::PAGE_TRANSITION_AUTO_BOOKMARK, false));
    if (url_it == urls.begin()) {
      // We opened the first URL which may have opened a new window or clobbered
      // the current page, reset the navigator just to be sure. |opened_tab| may
      // be null in tests.
      if (opened_tab)
        navigator = opened_tab;
      disposition = WindowOpenDisposition::NEW_BACKGROUND_TAB;
    }
  }
}
```
可以看到在OpenAll函数中调用了ShouldOpenAll函数来创建确认窗口，关键函数就是下面的
ShowQuestionMessageBox，看名字也可以了解到他的作用。
```
bool ShouldOpenAll(gfx::NativeWindow parent,
                   const std::vector<const BookmarkNode*>& nodes) {
  size_t child_count = GetURLsToOpen(nodes).size();
  if (child_count < kNumBookmarkUrlsBeforePrompting)
    return true;

  return ShowQuestionMessageBox(
             parent, l10n_util::GetStringUTF16(IDS_PRODUCT_NAME),
             l10n_util::GetStringFUTF16(IDS_BOOKMARK_BAR_SHOULD_OPEN_ALL,
                                        base::NumberToString16(child_count))) ==
         MESSAGE_BOX_RESULT_YES;
}
```

关于窗口的创建有一个调用链：ShowQuestionMessageBox -> MessageBoxDialog::Show -> ShowSync，前面的几个函数都没什么重要的，我们直接去分析ShowSync

```
void ShowQuestionMessageBox(
    gfx::NativeWindow parent,
    const std::u16string& title,
    const std::u16string& message,
    base::OnceCallback<void(MessageBoxResult)> callback) {
  MessageBoxDialog::Show(parent, title, message,
                         chrome::MESSAGE_BOX_TYPE_QUESTION, std::u16string(),
                         std::u16string(), std::u16string(),
                         std::move(callback));
}
```

```
chrome::MessageBoxResult MessageBoxDialog::Show(
    gfx::NativeWindow parent,
    const std::u16string& title,
    const std::u16string& message,
    chrome::MessageBoxType type,
    const std::u16string& yes_text,
    const std::u16string& no_text,
    const std::u16string& checkbox_text,
    MessageBoxDialog::MessageBoxResultCallback callback) {
  if (!callback)
    return ShowSync(parent, title, message, type, yes_text, no_text,
                    checkbox_text);

  startup_metric_utils::SetNonBrowserUIDisplayed();
  if (chrome::internal::g_should_skip_message_box_for_test) {
    std::move(callback).Run(chrome::MESSAGE_BOX_RESULT_YES);
    return chrome::MESSAGE_BOX_RESULT_DEFERRED;
  }
```

在ShowSync函数中将运行一个嵌套的消息循环run_loop以继续运行 ui 线程。
```
chrome::MessageBoxResult ShowSync(gfx::NativeWindow parent,
                                  const base::string16& title,
                                  const base::string16& message,
                                  chrome::MessageBoxType type,
                                  const base::string16& yes_text,
                                  const base::string16& no_text,
                                  const base::string16& checkbox_text) {
  chrome::MessageBoxResult result = chrome::MESSAGE_BOX_RESULT_NO;

  // TODO(pkotwicz): Exit message loop when the dialog is closed by some other
  // means than |Cancel| or |Accept|. crbug.com/404385
  base::RunLoop run_loop(base::RunLoop::Type::kNestableTasksAllowed);

  MessageBoxDialog::Show(
      parent, title, message, type, yes_text, no_text, checkbox_text,
      base::BindOnce(
          [](base::RunLoop* run_loop, chrome::MessageBoxResult* out_result,
             chrome::MessageBoxResult messagebox_result) {
            *out_result = messagebox_result;
            run_loop->Quit();
          },
          &run_loop, &result));

  run_loop.Run();
  return result;
}
```

这个时候相当于有两个窗口，一个原网页窗口，一个新创建的确认窗口，而此时确认窗口在运行消息循环，当我们关闭原网页窗口，保留确认窗口，在原网页窗口关闭后去点击确认，让消息循环退出，从而触发uaf