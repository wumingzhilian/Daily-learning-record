## Chrome

CVE-2020-6544：在迭代的过程中存在可以insert Hashmap的能力，导致Hashma重分配后迭代器失效（https://github.com/yytgravity/Daily-learning-record/blob/master/cve/11.20-12.10/try/CVE-2020-6544.md）

CVE-2020-6550：Resolve可以重入到js层，在js中通过remove iframe创造uaf（https://github.com/yytgravity/Daily-learning-record/blob/master/cve/11.20-12.10/try/CVE-2020-6550.md）

CVE-2020-6559：通过Resolve重入到js层，remove iframe释放render frame host，使得使用context时uaf（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-6559

CVE-2020-15967：将原始指针spec_传递给了ServiceWorkerPaymentApp，当PaymentRequestImpl被释放后，使用ServiceWorkerPaymentApp中的spec_触发uaf（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-15967）

CVE-2020-15998：scoped_refptr指针可以通过std::move(handle)被释放（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-15998）

CVE-2020-15990：注册KeyPressHandler时传入了AutofillPopupControllerImpl的原始指针，在renderframehost被释放后触发注册事件导致uaf（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-15990）

CVE-2019-5788：int整数溢出+unique_key的容器来制造悬空指针（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2019-5788）

CVE-2020-15996：在调用driver_中的虚函数时，没有检查driver_是否存在，driver_生命周期绑定renderframehost，可以通过remove iframe将driver_释放。（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-15996）

CVE-2020-16045：存在一个队列


## v8利用

CVE-2017-15401：通过调试partitionalloc，􏱫􏱎在无法leak object address的条件下通过􏱀􏲱􏱝Isolate完成利用（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2017-15401）

CVE-2019-5782：常规v8数组越界利用（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2019-5782）

CVE-2017-5070：v8优化漏洞（类型混淆），通过fakeMap和fakeArray的方式完成利用（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2017-5070）

Issue 716044：Array.prototype.map引发的特殊的数组越界（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/Issue%20716044）

Issue 746946：v8优化漏洞（类型混淆）（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/issue%20746946）

􏱋