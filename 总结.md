## Chrome
CVE-2019-5826：IndexedDBDatabase中存在的一个iterator invalid漏洞，OnConnectionClosed函数在最后一个连接被erase时会发生非预期情况，导致原始指针未正确从database_map中删除，之后通过AbortTransactionsForDatabase函数使database_map中的原始指针变为悬垂指针，导致uaf产生。（有完整利用）。
（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2019-5826）

CVE-2020-15967：将原始指针spec_传递给了ServiceWorkerPaymentApp，PaymentRequestImpl在mojo发生连接错误断开时会被释放，之后使用ServiceWorkerPaymentApp中的spec_触发uaf（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-15967）

CVE-2020-15998：scoped_refptr指针可以通过std::move(handle)被释放，但是他并没清除handles中push的device_handle，当设备被拔出或移除时，就会调用handle->Close();触发uaf（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-15998）

CVE-2020-15990：注册KeyPressHandler时传入了AutofillPopupControllerImpl的原始指针，在remove child iframe将RenderFrameHost被释放后通过keyevent触发注册事件导致uaf（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-15990）

CVE-2019-5788：int整数溢出+unique_key的容器来制造悬空指针，之后在Truncate函数中使用悬空指针导致uaf（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2019-5788）

CVE-2020-6544：在迭代的过程中存在可以insert Hashmap的能力，导致Hashma重分配后迭代器失效，之后callback->Run将会使用已失效的指针导致uaf（https://github.com/yytgravity/Daily-learning-record/blob/master/cve/11.20-12.10/try/CVE-2020-6544.md）

CVE-2020-6550：Resolve可以重入到js层，在js中通过remove iframe断开mojo连接，使Impl被释放，之后在调用clear时，导致uaf（https://github.com/yytgravity/Daily-learning-record/blob/master/cve/11.20-12.10/try/CVE-2020-6550.md）

CVE-2020-6559：通过Resolve重入到js层，remove iframe释放RenderFrameHost，使得使用GetExecutionContext()返回的指针时uaf（https://github.com/yytgravity/Daily-learning-record/blob/master/cve/CVE-2020-6559/CVE-2020-6559.md）

CVE-2020-15996：在调用driver_中的虚函数时，没有检查driver_是否存在，driver_生命周期绑定renderframehost，可以通过remove iframe将driver_释放，之后调用driver_中的虚函数触发uaf（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-15996）

CVE-2020-16045：存在一个回调队列，该队列生命周期独立于RenderFrameHost，但是其中的回调函数与renderframehost绑定，在renderframehost被释放后通过回调队列调用函数导致uaf的产生。（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-16045）

Issue 1101509：RawClipboardHostImpl生命周期独立于RenderFrameHost，但它其中的方法使用了render_frame_host_，通过写一个拦截器在child iframe被remove掉后，remote端仍被parent持有，所以message pipe不会被中断，和其绑定的child iframe里对应的RawClipboardHostImpl也不会被析构，但此时RawClipboardHostImpl里保存的child iframe的render_frame_host_已经被析构掉了，之后调用方法使用render_frame_host_导致uaf（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/Issue%201101509）

Issue 1122917：DirectSocketsServiceImpl没有继承自WebObserver等来观察renderframehost的生命周期，但在使用MakeSelfOwnedReceiver函数来创建一个self-owned的receiver时在DirectSocketsServiceImpl中存入了renderframehost。（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/Issue%201122917）

CVE-2020-6573：在observer中保存了launched_device_的实际指针，但在launched_device_被reset时并未处理observer，导致observer中保留了失效指针，之后使用observer中保存的指针导致uaf（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2020-6573）

Issue 1119865：Resolve重入js，在then中再次调用StopProfiler，使得delete掉的指针再次被使用。（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/Issue%201119865）

CVE-2019-13768：通过持有remote端回到js执行代码+被Unretained修饰的this指针，只由回调的调用者来保证回调执行时，this指针仍然可用。通过自定义getInternalUUID，将之前建立好的message pipe给断开，从而析构掉之前创建出的FileWriterImpl对象。这样再去调用DoWrite就会触发uaf。（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2019-13768）

## ctf

Google2019_wp:https://github.com/yytgravity/Daily-learning-record/tree/master/ctf/Google%202019

plaid 2020 mojo:https://github.com/yytgravity/Daily-learning-record/tree/master/ctf/plaid%202020%20mojo

tctf-chrome（rce+sbx+fullchain）：https://github.com/yytgravity/Daily-learning-record/tree/master/ctf/tctf-chrome

## v8

CVE-2017-15401：通过调试partitionalloc，􏱫􏱎在无法leak object address的条件下通过􏱀􏲱􏱝Isolate完成利用（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2017-15401）

CVE-2019-5782：常规v8数组越界利用（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2019-5782）

CVE-2017-5070：v8优化漏洞（类型混淆），通过fakeMap和fakeArray的方式完成利用（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2017-5070）

Issue 716044：Array.prototype.map引发的特殊的数组越界（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/Issue%20716044）

Issue 746946：v8优化漏洞（类型混淆）（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/issue%20746946）

CVE-2018-6065：v8数组越界漏洞。（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/v8/CVE-2018-6065）

CVE-2017-5116：存储在SharedArrayBuffer中的wasm可以利用web worker来实现条件竞争来修改wasm code。（https://github.com/yytgravity/Daily-learning-record/tree/master/cve/CVE-2017-5116）

逃逸分析：
N1CTF2020 Escape：https://github.com/yytgravity/Daily-learning-record/tree/master/ctf/N1CTF2020%20Escape

## linux kernel
CVE-2019-9213：0地址解引用漏洞，cap_capable函数在检查权限时存在缺陷，在跨进程的条件下，只检测当前进程的权限，使得可以通过两个进程来绕过security_mmap_addr函数。（https://github.com/yytgravity/Daily-learning-record/blob/master/cve/cve-2019-9213/9213.md）

CVE-2019-8956：sctp_sendmsg函数中的链表遍历操作时，没有对列表项被删除的情况作出处理，导致列表项被删除后依旧使用它获取成员，这样造成了漏洞的产生。（https://github.com/yytgravity/Daily-learning-record/blob/master/cve/cve-2019-8956/8956.md）
利用9213和8956两个漏洞完成了完整利用。

cve-2016-4486：rtnl_fill_link_ifmap函数中没有对结构体初始化，该结构体大小为28字节，之后会因为编译器的对齐，而使四字节的内核信息泄漏。（https://github.com/yytgravity/Daily-learning-record/blob/master/cve/cve-2016-4486/paper.md）

调试复现了脏牛漏洞。

## 文件格式

1、初始winafl--通过复现该文章内容学习了winafl的使用 （https://www.freebuf.com/articles/system/216437.html ）

- 练习笔记：https://github.com/yytgravity/Daily-learning-record/tree/master/FileFormat-fuzz/winafl-exercise

2、通过学习DynamoRIO来初步理解插桩

- 笔记：https://github.com/yytgravity/Daily-learning-record/tree/master/FileFormat-fuzz/DynamoRIO

3、阅读了一些winafl的入门案例
- https://symeonp.github.io/2017/09/17/fuzzing-winafl.html

- https://www.apriorit.com/dev-blog/644-reverse-vulnerabilities-software-no-code-dynamic-fuzzing

4、通过（https://www.apriorit.com/dev-blog/640-qa-fuzzing-for-closed-source-windows-software ）学习如何对闭源二进制文件进行文件格式fuzz，总结如下：
- 找到我们想要fuzz的功能。
- 逆向。
- 编写一个调用上面逆向的API的程序（harness）。
- 借助DynamoRIO查看覆盖率。
- 重复上述过程，直到完全覆盖到了想要的fuzz的函数。


5、学习adobe中的文件格式fuzz

- 通过（https://research.checkpoint.com/2018/50-adobe-cves-in-50-days/ ）练习通过逆向调试的方法为JP2KLib.dll编写harness
- Adobe Reader调试符号相关（https://www.4hou.com/posts/4Y0k ）

6、gdi实战
学习资料：
- https://www.ixiacom.com/company/blog/investigating-windows-graphics-vulnerabilities-reverse-engineering-and-fuzzing-story

- https://www.pentestpartners.com/security-blog/time-travel-debugging-finding-windows-gdi-flaws/

我的gdi harness代码：
https://github.com/yytgravity/Daily-learning-record/tree/master/FileFormat-fuzz/gdi

7、pbk实战
学习资料：
- https://symeonp.github.io/2020/12/08/phonebook-uaf-analysis.html

我的harness代码：
https://github.com/yytgravity/Daily-learning-record/tree/master/FileFormat-fuzz/pbk

8、学习.LNK格式fuzz寻找攻击面

- https://blog.vincss.net/2020/06/cve49-microsoft-windows-lnk-remote-code-execution-vuln-cve-2020-1299-eng.html 
- https://www.zerodayinitiative.com/blog/2020/3/25/cve-2020-0729-remote-code-execution-through-lnk-files

感想：之前大部分的关于.lnk的fuzz都是在shell32.dll和windows.storage.dll上进行的，windows.storage.search.dll 和StructuredQuery.dll应该还是有可挖掘的余地。

9、学习.CAB格式fuzz

- https://www.zerodayinitiative.com/blog/2020/7/8/cve-2020-1300-remote-code-execution-through-microsoft-windows-cab-files

10、学习AFL
- AFL代码阅读：https://github.com/yytgravity/Daily-learning-record/tree/master/afl

11、尝试过使用frida辅助harness的编写
- 修改frida-trace来打印参数返回值：https://github.com/yytgravity/Daily-learning-record/tree/master/frida/try
􏱋